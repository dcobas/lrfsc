head	1.13;
access;
symbols;
locks
	lewis:1.13; strict;
comment	@ * @;


1.13
date	2008.06.19.12.27.47;	author lewis;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.19.11.54.37;	author lewis;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.19.11.23.04;	author lewis;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.19.11.19.40;	author lewis;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.18.17.32.12;	author lewis;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.18.12.41.31;	author lewis;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.17.16.47.52;	author lewis;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.17.14.49.34;	author lewis;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.17.08.16.35;	author lewis;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.12.15.39.21;	author lewis;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.11.13.14.48;	author lewis;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.10.08.42.13;	author lewis;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.09.12.53.32;	author lewis;	state Exp;
branches;
next	;


desc
@@


1.13
log
@*** empty log message ***
@
text
@/* ------------------------------------- */
/* Lrfsc Device driver                   */
/* Julian Lewis AB/CO/HT 28/Apr/2008     */


/* Dont define the module more than once */

#ifndef LRFSCDRVR
#define LRFSCDRVR

/* ------------------------------------- */
/* Constants                             */
/* ------------------------------------- */

#define LrfscDrvrMODULE_CONTEXTS 1  /* 2 modules max. to be installed  */
#define LrfscDrvrCLIENT_CONTEXTS 16  /* Max number of open file handlers */
#define LrfscDrvrDEFAULT_TIMEOUT 1000

/* ------------------------------------ */
/* Interrupt sources                    */

typedef enum {
   LrfscDrvrInterruptPULSE          = 0x1,  /* Falling edge of RF on pulse          */
   LrfscDrvrInterruptSTART_CYCLE    = 0x2   /* Rising edge of start cycle pulse     */
 } LrfscDrvrInterrupt;

#define LrfscDrvrINTERUPT_MASK 0x3
#define LrfscDrvrINTERRUPTS 2
 
typedef enum {
    LrfscDrvrPulseALL,
    LrfscDrvrPulse1,
    LrfscDrvrPulse2,
    LrfscDrvrPulse3,
    LrfscDrvrPulse4,
    LrfscDrvrPulse5
} LrfscDrvrPulse;

#define LrfscDrvrPULSES 5

typedef struct {
   unsigned long        Module;    /* The module number 1..n     */
   LrfscDrvrInterrupt	Interrupt; /* The intterrupt source */
   LrfscDrvrPulse       Pulse;     /* Pulse 0=>All */
 } LrfscDrvrConnection;
 
typedef struct {
   unsigned long        Pid;       /* Pid of client whos connections you want */
   unsigned long        Size;      /* Number of connection entries */
   LrfscDrvrConnection	Connections[LrfscDrvrMODULE_CONTEXTS];	/* The connections it has */
 } LrfscDrvrClientConnections;
 
typedef struct {
   unsigned long Size;
   unsigned long Pid[LrfscDrvrCLIENT_CONTEXTS];
 } LrfscDrvrClientList;
 
 /* ------------------------------------ */
 /* Control commands                     */

typedef enum {
   LrfscDrvrControlNONE        = 0x0,
   LrfscDrvrControlDO_AQN      = 0x1,  /* Request a synchronous acquisition */
   LrfscDrvrControlCONT_WAVE   = 0x2,  /* Set mode to continuous wave (CW) */
   LrfscDrvrControlWINDUP_OFF  = 0x4,  /* Turn anti-windup off in the PIC */
   LrfscDrvrControlSATCTRL_OFF = 0x8   /* Turn stauration control of in the PIC */
} LrfscDrvrControl;

#define LrfscDrvrCONTROLS 5
  
/* ----------------------------------------------------- */
/* Driver and VHDL Firmware Version date UTC times       */
 
typedef struct {
   unsigned long Firmware;
   unsigned long Driver;
 } LrfscDrvrVersion;
 
/* ----------------------------------------------------- */
/* Module status (Cleared on read)                       */
 
typedef enum {
   LrfscDrvrStatusOVER_REF         = 0x01, /* Over range in reflected signal ADC */
   LrfscDrvrStatusOVER_FWD         = 0x02, /* Over range in forward signal ADC */
   LrfscDrvrStatusOVER_CAV         = 0x04, /* Over range in cavity signal ADC */
   LrfscDrvrStatusRF_TOO_LONG      = 0x08, /* RF pulse is too long (>RfOnMaxLen) */
   LrfscDrvrStatusNO_FAST_PROTECT  = 0x10, /* When set its OK else protection is on */
   LrfscDrvrStatusMISSING_TICK     = 0x20  /* Missing IQ clock tick */
 } LrfscDrvrStatus;
 
#define LrfscDrvrSTATAE 6
 
/* ----------------------------------------------------- */
/* 16-Bit short Raw IO                                   */

typedef struct {
   unsigned short Size;      	/* Number long to read/write */
   unsigned short Offset;    	/* Offset address space      */
   unsigned short *UserArray;	/* Callers data area for  IO */
   unsigned short RamFlag;		/* Set when accessing RAM */
 } LrfscDrvrRawIoBlock;

/* ------------------------------------ */
/* State of the module / driver         */
/*    LrfscDrvrSET_STATE,               */
/*    LrfscDrvrGET_STATE,               */

typedef enum {
   LrfscDrvrStateCONFIG,
   LrfscDrvrStatePROD_LOCAL,
   LrfscDrvrStatePROD_REMOTE
 } LrfscDrvrState;

#define LrfscDrvrSTATES 3

/* ------------------------------------ */
/* Diagnostic choices                   */
/*    LrfscDrvrSET_DIAG_CHOICE          */
/*    LrfscDrvrGET_DIAG_CHOICE          */

typedef enum {
   LrfscDrvrDiagREFLECTED,  /* Reflected */
   LrfscDrvrDiagFORWARD,    /* Forward   */
   LrfscDrvrDiagCAVITY,     /* Cavity    */
   LrfscDrvrDiagCAVEERROR,  /* CavityErr */
   LrfscDrvrDiagOUTPUT      /* Output    */
 } LrfscDrvrDiagSignalChoice;

#define LrfscDrvrDiagSIGNALS 5
#define LrfscDrvrDiagSIGNAL_CHOICES 4

typedef LrfscDrvrDiagSignalChoice LrfscDrvrDiagChoices[LrfscDrvrDiagSIGNAL_CHOICES];
 
 /* ------------------------------------ */
 /* An IQ buffer                         */

typedef struct {
    signed short I;
    signed short Q;
 } LrfscDrvrIQPair; /* Two 14 Bit signed values is one IQ pair */

#define LrfscDrvrBUF_IQ_ENTRIES 0x200
typedef LrfscDrvrIQPair LrfscDrvrBufIqArray[LrfscDrvrBUF_IQ_ENTRIES]; /* For acquisitions */

/* ------------------------------------ */
/* Analogue Switch Control bits         */
/*    LrfscDrvrSET_ANALOGUE_SWITCH      */
/*    LrfscDrvrGET_ANALOGUE_SWITCH      */

typedef enum {
   LrfscDrvrAnalogSwitchREF_TEST = 0x1,
   LrfscDrvrAnalogSwitchFWD_TEST = 0x2,
   LrfscDrvrAnalogSwitchCAV_TEST = 0x4,
   LrfscDrvrAnalogSwitchOUT_TEST = 0x8
 } LrfscDrvrAnalogSwitch;

#define LrfscDrvrAnalogSWITCHES 4

/* ------------------------------------ */
/* Software Switch Control bits         */
/* Soft Switch in FPGA                  */
/*    LrfscDrvrSET_SOFT_SWITCH          */
/*    LrfscDrvrGET_SOFT_SWITCH          */

typedef enum {
   LrfscDrvrSotfSwitchMAIN_CLOSED = 0x0,
   LrfscDrvrSoftSwitchMAIN_OPEN   = 0x1
 } LrfscDrvrSoftSwitch;

#define LrfscDrvrSoftSWITCHES 2

/* ------------------------------------ */
/* For each matric there are 4 coefs    */
/*    LrfscDrvrSET_COEFFICIENTS         */
/*    LrfscDrvrGET_COEFFICIENTS         */

typedef enum {
   LrfscDrvrMatrixREF, /* Reflected */
   LrfscDrvrMatrixFWD, /* Feed forward */
   LrfscDrvrMatrixCAV  /* Cavity */
 } LrfscDrvrMatrix;

#define LrfscDrvrMatrixMATRICES 3

typedef struct {
   signed short MatrixA;
   signed short MatrixB;
   signed short MatrixC;
   signed short MatrixD;
 } LrfscDrvrMatrixCoefficients;

typedef struct {
   LrfscDrvrMatrix             Matrix;
   LrfscDrvrMatrixCoefficients Coeficients;
 } LrfscDrvrMatrixCoefficientsBuf;

/* ------------------------------------ */
/* Snap Shots                           */
/*    LrfscDrvrGET_SNAP_SHOTS           */
/* The snap shot time is set by ...     */
/*    LrfscDrvrSET_SNAP_SHOT_TIME       */

typedef struct {
   unsigned short  DiagTime;    /* Time after RFON for snapshot 40MHz ticks */
   LrfscDrvrIQPair RefDiag;     /* Reflected */
   LrfscDrvrIQPair FwdDiag;     /* Forware */
   LrfscDrvrIQPair CavDiag;     /* Cavity */
   LrfscDrvrIQPair ErrDiag;     /* Error */
   LrfscDrvrIQPair OutDiag;     /* Output */
   LrfscDrvrIQPair POutDiag;    /* PI controler gain */
   LrfscDrvrIQPair IOutDiag;    /* PI integrator */
 } LrfscDrvrDiagSnapShot;

/* ------------------------------------ */
/* Resonance control                    */
/*    LrfscDrvrSET_RES_CTRL             */
/*    LrfscDrvrGET_RES_CTRL             */

typedef struct {
   unsigned short  Time;    /* RW Control time */
   unsigned short  Value;   /* RW Control value */
   LrfscDrvrIQPair Fwd;     /* RO X Forward */
   LrfscDrvrIQPair Cav;     /* RO X Cavity */
 } LrfscDrvrResCtrl;

/* ------------------------------------ */
/* Set the PIC constants                */
/*    LrfscDrvrSET_PIC                  */

typedef struct {
   signed short KP;    /* Proportional gain of PI controller */
   signed short KI;    /* Integral gain of PI controller     */
 } LrfscDrvrPicSetBuf;

/* ------------------------------------ */
/* Cycle configurations                 */
/*    LrfscDrvrSET_CYCLE_CONFIG         */
/*    LrfscDrvrGET_CYCLE_CONFIG         */

#define LrfscDrvrCYCLES 0x10
#define LrfscDrvrCONFIGS 2
#define LrfscDrvrCONFIG_POINTS 0x200

typedef enum {
   LrfscDrvrConfigSETPOINTS,   /* SetPoints   */
   LrfscDrvrConfigFEEDFORWARD  /* FeedForward */
 } LrfscDrvrConfig;

typedef struct {
   unsigned short  Ticks;   /* 5MHz clock ticks */
   LrfscDrvrIQPair IQ;      /* IQ Value */
 } LrfscDrvrConfigPoint;

typedef enum {
   LrfscDrvrFunctionSTOP,   /* Stop the function */
   LrfscDrvrFunctionREPEAT, /* Repeat the function */
 } LrfscDrvrFunction;

typedef LrfscDrvrConfigPoint LrfscDrvrConfigArray[LrfscDrvrCONFIG_POINTS];

typedef struct {
   LrfscDrvrConfig      Which;                          /* Which configuration ram */
   LrfscDrvrFunction    Flag;                           /* Repeat/Stop flag */
   unsigned long        Points;                         /* Number of points in buffer */
   unsigned long        Cycle;                          /* Cycle number 0..31 */
   LrfscDrvrConfigArray Array;                          /* Configuration array */
 } LrfscDrvrConfigBuf;

/* ------------------------------------ */
/* Diagnostics                          */
/*    LrfscDrvrSET_PULSE                */
/*    LrfscDrvrGET_DIAGNOSTICS          */

typedef struct {
   unsigned long                Size;   /* Set your buffer size in IQ Pairs */
   LrfscDrvrPulse               Pulse;  /* Set the pulse */
   LrfscDrvrDiagSignalChoice	Choice;	/* Set your choice of signal */
   unsigned long                Cycle;  /* Set the cycle number 0..31 you want */
   
   unsigned long                SkipStart;  /* Returns Start of acquisition */
   unsigned long                SkipCount;  /* Returns Distance between samples */
   unsigned long                Valid;      /* Returns True id diagnostic data is valid */
   LrfscDrvrBufIqArray          Array;      /* Returns Array of acquired pulses */
 } LrfscDrvrDiagBuf;

/************************/
/* IO Control functions */
/************************/

typedef enum {
   
   LrfscDrvrSET_MODULE,             /* ulong Set module for read/write 1..2 */
   LrfscDrvrGET_MODULE,             /* ulong Get module for read/write 1..2 */
   LrfscDrvrGET_MODULE_COUNT,       /* ulong Get number of installed modules */
   LrfscDrvrGET_MODULE_ADDRESS,     /* LrfscDrvrModuleAddress Read */
   LrfscDrvrRESET,                  /* NULL Reset the module and driver */
   LrfscDrvrGET_STATUS,             /* LrfscDrvrStatus Get status */

   LrfscDrvrSET_SW_DEBUG,           /* ulong Set software debug level */
   LrfscDrvrGET_SW_DEBUG,           /* ulong Get software debug level */

   LrfscDrvrRAW_READ,               /* LrfscDrvrRawIoBlock Read  */
   LrfscDrvrRAW_WRITE,              /* LrfscDrvrRawIoBlock Write */

   LrfscDrvrSET_TIMEOUT,            /* ulong Set read timeout */
   LrfscDrvrGET_TIMEOUT,            /* ulong Get read timeout */

   LrfscDrvrCONNECT,                /* LrfscDrvrConnection Connect to interrupt */
   LrfscDrvrDISCONNECT,             /* LrfscDrvrConnection DisConnect from interrupt */

   LrfscDrvrSET_QUEUE_FLAG,         /* ulong Set queue off 1 or on 0 */
   LrfscDrvrGET_QUEUE_FLAG,
   LrfscDrvrGET_QUEUE_SIZE,
   LrfscDrvrGET_QUEUE_OVERFLOW,

   LrfscDrvrGET_CLIENT_LIST,        /* LrfscDrvrClientList Get all clients */
   LrfscDrvrGET_CLIENT_CONNECTIONS, /* LrfscDrvrClientConnections Get clients connections */

   LrfscDrvrSET_STATE,              /* LrfscDrvrState Get Module state */
   LrfscDrvrGET_STATE,

   LrfscDrvrSET_DIAG_CHOICE,        /* LrfscDrvrDiagChoices Configure diagnostics channels */
   LrfscDrvrGET_DIAG_CHOICE,

   LrfscDrvrSET_RES_CTRL,           /* LrfscDrvrResCtrl Set Resonance control value */
   LrfscDrvrGET_RES_CTRL,

   LrfscDrvrSET_ANALOGUE_SWITCH,    /* LrfscDrvrAnalogSwitch */
   LrfscDrvrGET_ANALOGUE_SWITCH,

   LrfscDrvrSET_SOFT_SWITCH,        /* LrfscDrvrSoftSwitch */
   LrfscDrvrGET_SOFT_SWITCH,

   LrfscDrvrSET_COEFFICIENTS,       /* LrfscDrvrMatrixCoefficientsBuf */
   LrfscDrvrGET_COEFFICIENTS,

   LrfscDrvrSET_SNAP_SHOT_TIME,     /* ulong Snapshot time */
   LrfscDrvrGET_SNAP_SHOTS,         /* LrfscDrvrDiagSnapShotBuf */

   LrfscDrvrSET_PIC,                /* LrfscDrvrPicSetBuf PI Controller */
   LrfscDrvrGET_PIC,

   LrfscDrvrGET_PULSE_LENGTH,       /* ulong RF Pulse length */
   LrfscDrvrSET_MAX_PULSE_LENGTH,   /* ulong maximum RF pulse length */
   LrfscDrvrGET_MAX_PULSE_LENGTH,   /* ulong maximum RF pulse length */

   LrfscDrvrSET_NEXT_CYCLE,         /* ulong Next cycle 1..32 */
   LrfscDrvrGET_PRES_CYCLE,

   LrfscDrvrSET_CYCLE_CONFIG,       /* LrfscDrvrConfigBuf Set a cycle configuration */
   LrfscDrvrGET_CYCLE_CONFIG,       /* LrfscDrvrConfigBuf Get a cycle configuration */

   LrfscDrvrSET_SKIP_COUNT,         /* ulong Set diagnostic skip count */
   LrfscDrvrSET_SKIP_START,         /* ulong Set diagnostic skip count */
   LrfscDrvrSET_PULSE,              /* LrfscDrvrPulse Set acquisition pulse */
   LrfscDrvrGET_DIAGNOSTICS,        /* LrfscDrvrDiagBuf Get a diagnostic ram */

   LrfscDrvrGET_VERSION             /* LrfscDrvrVersion Get UTC version dates */

 } LrfscDrvrControlFunction;

#endif
@


1.12
log
@*** empty log message ***
@
text
@d240 1
a240 1
#define LrfscDrvrCYCLES 0x20
@


1.11
log
@*** empty log message ***
@
text
@d16 1
a16 1
#define LrfscDrvrCLIENT_CONTEXTS 8  /* Max number of open file handlers */
d240 1
a240 1
#define LrfscDrvrCYCLES 0x10
@


1.10
log
@*** empty log message ***
@
text
@d240 1
a240 1
#define LrfscDrvrCYCLES 0x20
@


1.9
log
@*** empty log message ***
@
text
@d15 2
a16 2
#define LrfscDrvrMODULE_CONTEXTS 2  /* 2 modules max. to be installed  */
#define LrfscDrvrCLIENT_CONTEXTS 16 /* Max number of open file handlers */
@


1.8
log
@*** empty log message ***
@
text
@d15 1
a15 1
#define LrfscDrvrMODULE_CONTEXTS 16 /* 16 modules max. to be installed  */
d271 1
a271 1
/*    LrfscDrvrSET_PULSE_MASK           */
@


1.7
log
@*** empty log message ***
@
text
@d250 2
a251 2
   unsigned short  Ticks;    /* 5MHz clock ticks */
   LrfscDrvrIQPair IQ;       /* IQ Value */
a265 1
   unsigned long        Valid;                          /* True when config is valid */
@


1.6
log
@*** empty log message ***
@
text
@d142 2
a143 2
#define LrfscDrvrBUF_IQ_ENTRIES 0x1000
typedef LrfscDrvrIQPair LrfscDrvrBufIqArray[LrfscDrvrBUF_IQ_ENTRIES];
d241 2
d249 11
a259 1
#define LrfscDrvrCONFIGS 2
d262 6
a267 6
   LrfscDrvrConfig     Which;
   unsigned long       Items;
   unsigned long       Start;
   unsigned long       Cycle;  /* 1..32 */
   LrfscDrvrBufIqArray Array;
   unsigned long       Valid;  /* True when config is valid */
@


1.5
log
@*** empty log message ***
@
text
@d344 1
a344 1
   LrfscDrvrSET_PULSE_MASK,         /* LrfscDrvrPulse Set acquisition pulses */
@


1.4
log
@*** empty log message ***
@
text
@d23 2
a24 2
   LrfscDrvrInterruptPULSE			= 0x1,	/* Falling edge of RF on pulse		*/
   LrfscDrvrInterruptSTART_CYCLE	= 0x2	/* Rising edge of start cycle pulse	*/
d31 6
a36 5
	LrfscDrvrPulse1 = 0x01,
    LrfscDrvrPulse2 = 0x02,
    LrfscDrvrPulse3 = 0x04,
    LrfscDrvrPulse4 = 0x08,
    LrfscDrvrPulse5 = 0x10
d39 1
a39 1
 #define LrfscDrvrPULSES 5
d44 1
a44 1
   LrfscDrvrPulse       Pulses;    /* Pulse or pulses */
d48 2
a49 2
   unsigned long		Pid;									/* Pid of client whos connections you want */
   unsigned long		Size;									/* Number of connection entries */
d61 7
a67 7
 typedef enum {
 	LrfscDrvrControlNONE		= 0x0,
 	LrfscDrvrControlDO_AQN		= 0x1,	/* Request a synchronous acquisition */
 	LrfscDrvrControlCONT_WAVE	= 0x2,	/* Set mode to continuous wave (CW) */
 	LrfscDrvrControlWINDUP_OFF	= 0x4,	/* Turn anti-windup off in the PIC */
 	LrfscDrvrControlSATCTRL_OFF = 0x8	/* Turn stauration control of in the PIC */
  } LrfscDrvrControl;
d69 1
a69 1
 #define LrfscDrvrCONTROLS 5
d83 7
a89 7
	LrfscDrvrStatusOVER_REF			= 0x01,	/* Over range in reflected signal ADC */
	LrfscDrvrStatusOVER_FWD			= 0x02,	/* Over range in forward signal ADC */
	LrfscDrvrStatusOVER_CAV			= 0x04,	/* Over range in cavity signal ADC */
	LrfscDrvrStatusRF_TOO_LONG		= 0x08,	/* RF pulse is too long (>RfOnMaxLen) */
	LrfscDrvrStatusNO_FAST_PROTECT	= 0x10,	/* When set its OK else protection is on */
	LrfscDrvrStatusMISSING_TICK		= 0x20	/* Missing IQ clock tick */
 }	LrfscDrvrStatus;
d142 1
a142 1
#define LrfscDrvrBUF_IQ_ENTRIES 0x200
d151 4
a154 4
   LrfscDrvrAnalogSwitchREF_TEST	= 0x1,
   LrfscDrvrAnalogSwitchFWD_TEST	= 0x2,
   LrfscDrvrAnalogSwitchCAV_TEST  	= 0x4,
   LrfscDrvrAnalogSwitchOUT_TEST  	= 0x8
d203 10
a212 10
 typedef struct {
    unsigned short	DiagTime;	/* Time after RFON for snapshot 40MHz ticks */
    LrfscDrvrIQPair	RefDiag;	/* Reflected */
    LrfscDrvrIQPair	FwdDiag;	/* Forware */
    LrfscDrvrIQPair	CavDiag;	/* Cavity */
    LrfscDrvrIQPair	ErrDiag;	/* Error */
    LrfscDrvrIQPair	OutDiag;	/* Output */
    LrfscDrvrIQPair	POutDiag;	/* PI controler gain */
    LrfscDrvrIQPair	IOutDiag;	/* PI integrator */
  } LrfscDrvrDiagSnapShot;
d220 4
a223 4
   unsigned short 	Time;	/* RW Control time */
   unsigned short 	Value;		/* RW Control value */
   LrfscDrvrIQPair	Fwd;			/* RO X Forward */
   LrfscDrvrIQPair	Cav;			/* RO X Cavity */
d250 6
a255 6
	LrfscDrvrConfig		Which;
	unsigned long           Items;
	unsigned long		Start;
	unsigned long		Cycle;  /* 1..32 */
	LrfscDrvrBufIqArray	Array;
	unsigned long		Valid;	/* True when config is valid */
a262 3
#define LrfscDrvrDIAGNOSTIC_BUF_SIZE 0x800
typedef unsigned short LrfscDrvrDiagArray[LrfscDrvrDIAGNOSTIC_BUF_SIZE];

d265 1
a265 1
   LrfscDrvrPulse               Pulses; /* Set the pulses mask, one pulse only */
d267 1
a267 1
   unsigned long                Cycle;  /* Set the cycle number 1..32 you want */
d269 4
a272 4
   unsigned long                SkipStart;              /* Returns Start of acquisition */
   unsigned long                SkipCount;              /* Returns Distance between samples */
   unsigned long                Valid;                  /* Returns True id diagnostic data is valid */
   LrfscDrvrBufIqArray          Array[LrfscDrvrPULSES]; /* Returns Array of acquired pulses */
d281 20
a300 20
   LrfscDrvrSET_MODULE,			/* ulong Set module for read/write 1..2 */
   LrfscDrvrGET_MODULE,			/* ulong Get module for read/write 1..2 */
   LrfscDrvrGET_MODULE_COUNT,	/* ulong Get number of installed modules */
   LrfscDrvrGET_MODULE_ADDRESS, /* LrfscDrvrModuleAddress Read */
   LrfscDrvrRESET,				/* NULL Reset the module and driver */
   LrfscDrvrGET_STATUS,			/* LrfscDrvrStatus Get status */
   
   LrfscDrvrSET_SW_DEBUG,		/* ulong Set software debug level */
   LrfscDrvrGET_SW_DEBUG,		/* ulong Get software debug level */
   
   LrfscDrvrRAW_READ,			/* LrfscDrvrRawIoBlock Read  */
   LrfscDrvrRAW_WRITE,			/* LrfscDrvrRawIoBlock Write */
   
   LrfscDrvrSET_TIMEOUT,		/* ulong Set read timeout */
   LrfscDrvrGET_TIMEOUT,		/* ulong Get read timeout */
   
   LrfscDrvrCONNECT,			/* LrfscDrvrConnection Connect to interrupt */
   LrfscDrvrDISCONNECT,			/* LrfscDrvrConnection DisConnect from interrupt */
   
   LrfscDrvrSET_QUEUE_FLAG,		/* ulong Set queue off 1 or on 0 */
a303 3
 
   LrfscDrvrGET_CLIENT_LIST,		/* LrfscDrvrClientList Get all clients */
   LrfscDrvrGET_CLIENT_CONNECTIONS,	/* LrfscDrvrClientConnections Get clients connections */
d305 4
a308 1
   LrfscDrvrSET_STATE,			/* LrfscDrvrState Get Module state */
d311 1
a311 1
   LrfscDrvrSET_DIAG_CHOICE,	/* LrfscDrvrDiagChoices Configure diagnostics channels */
d314 1
a314 1
   LrfscDrvrSET_RES_CTRL,		/* LrfscDrvrResCtrl Set Resonance control value */
d317 1
a317 1
   LrfscDrvrSET_ANALOGUE_SWITCH,/* LrfscDrvrAnalogSwitch */	
d320 1
a320 1
   LrfscDrvrSET_SOFT_SWITCH,	/* LrfscDrvrSoftSwitch */
d323 1
a323 1
   LrfscDrvrSET_COEFFICIENTS,	/* LrfscDrvrMatrixCoefficientsBuf */
d326 2
a327 2
   LrfscDrvrSET_SNAP_SHOT_TIME,	/* ulong Snapshot time */
   LrfscDrvrGET_SNAP_SHOTS,		/* LrfscDrvrDiagSnapShotBuf */
d329 1
a329 1
   LrfscDrvrSET_PIC,			/* LrfscDrvrPicSetBuf PI Controller */
d332 5
a336 5
   LrfscDrvrGET_PULSE_LENGTH,     /* ulong RF Pulse length */
   LrfscDrvrSET_MAX_PULSE_LENGTH, /* ulong maximum RF pulse length */
   LrfscDrvrGET_MAX_PULSE_LENGTH, /* ulong maximum RF pulse length */
   
   LrfscDrvrSET_NEXT_CYCLE,		/* ulong Next cycle 1..32 */
d339 2
a340 2
   LrfscDrvrSET_CYCLE_CONFIG,	/* LrfscDrvrConfigBuf Set a cycle configuration */
   LrfscDrvrGET_CYCLE_CONFIG,	/* LrfscDrvrConfigBuf Get a cycle configuration */
d342 4
a345 4
   LrfscDrvrSET_SKIP_COUNT,		/* ulong Set diagnostic skip count */
   LrfscDrvrSET_SKIP_START,		/* ulong Set diagnostic skip count */
   LrfscDrvrSET_PULSE_MASK,		/* LrfscDrvrPulse Set acquisition pulses */
   LrfscDrvrGET_DIAGNOSTICS,	/* LrfscDrvrDiagBuf Get a diagnostic ram */
d347 1
a347 1
   LrfscDrvrGET_VERSION			/* LrfscDrvrVersion Get UTC version dates */
@


1.3
log
@*** empty log message ***
@
text
@d41 1
a41 1
   unsigned long		Module;    /* The module number 1..n     */
d43 1
a43 1
   LrfscDrvrPulse		Pulses;    /* Pulse or pulses */
d137 1
a137 1
	signed short I;
d250 1
a250 1
	unsigned long		End;
d266 2
a267 2
   unsigned long				Size;	/* Set your buffer size in IQ Pairs */
   LrfscDrvrPulse				Pulses;	/* Set the pulses mask, one pulse only */
d269 1
a269 1
   unsigned long				Cycle;	/* Set the cycle number 1..32 you want */
d271 4
a274 4
   unsigned long				SkipStart;				/* Returns Start of acquisition */ 
   unsigned long				SkipCount;				/* Returns Distance between samples */
   unsigned long				Valid;					/* Returns True id diagnostic data is valid */
   LrfscDrvrBufIqArray			Array[LrfscDrvrPULSES];	/* Returns Array of acquired pulses */	
d334 1
a334 1
   LrfscDrvrGET_PULSE_LENGTH,	/* ulong RF Pulse length */
d336 1
@


1.2
log
@*** empty log message ***
@
text
@d56 11
d68 2
a149 1
   LrfscDrvrAnalogSwitchNORMAL		= 0x0,
d156 1
a156 1
#define LrfscDrvrAnalogSWITCHES 5
d219 4
a222 2
   unsigned short ResCtrlTime;
   unsigned short ResCtrl;
d288 1
d348 1
a348 1
   LrfscDrvrGET_VERSION
@


1.1
log
@Initial revision
@
text
@d45 11
d271 2
d275 3
d281 3
d286 8
d333 1
a333 1
   LrfscDrvrGET_GET_VERSION
@
