head	1.19;
access;
symbols;
locks
	lewis:1.19; strict;
comment	@ * @;


1.19
date	2008.06.19.15.23.44;	author lewis;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.19.13.03.59;	author lewis;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.19.12.27.47;	author lewis;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.19.11.45.11;	author lewis;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.19.11.12.33;	author lewis;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.18.17.32.12;	author lewis;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.18.12.41.31;	author lewis;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.17.14.49.34;	author lewis;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.17.13.03.15;	author lewis;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.17.12.53.38;	author lewis;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.16.11.47.48;	author lewis;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.16.10.44.02;	author lewis;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.16.09.31.28;	author lewis;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.12.15.41.00;	author lewis;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.12.15.39.21;	author lewis;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.11.13.16.15;	author lewis;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.11.13.14.48;	author lewis;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.10.08.42.13;	author lewis;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.09.12.53.32;	author lewis;	state Exp;
branches;
next	;


desc
@@


1.19
log
@*** empty log message ***
@
text
@/* ====================================================================== */
/* Lowlevel RF module driver LRFC                                         */
/* Julian Lewis Monday 5th May 2008                                       */
/* ====================================================================== */

#include <dldd.h>
#include <errno.h>
#include <kernel.h>
#include <io.h>
#include <sys/ioctl.h>
#include <time.h>
#include <sys/ioctl.h>
#include <sys/timeout.h>
#include <mem.h>
#include <sys/file.h>
#include <string.h>
#include <signal.h>
#include <conf.h>

#include <lrfscdrvr.h>
#include <lrfscdrvrP.h>

#ifndef COMPILE_TIME
#define COMPILE_TIME 0
#endif

extern int  kkprintf(char *, ...);
extern void cprintf  _AP((char *fmt, ...));
extern int  swait    _AP((int *sem, int flag));
extern int  ssignal  _AP((int *sem));
extern int  ssignaln _AP((int *sem, int count));
extern int  scount   _AP((int *sem));
extern int  sreset   _AP((int *sem));
extern void sysfree  _AP((char *, long));
extern int  recoset  _AP((void));
extern void noreco   _AP((void));
extern int _kill     _AP((int pid, int signal));
extern int _killpg   _AP((int pgrp, int signal));
extern pid_t getpid  _AP((void));

extern  char *sysbrk ();
extern  int  timeout ();

#ifndef OK
#define OK 0
#endif

#ifndef SYSERR
#define SYSERR (-1)
#endif

/* ====================================================================== */
/* references specifics to CES PowerPC Cpus RIO806x                       */

#include <ces/vmelib.h>

extern unsigned long find_controller();
extern unsigned long return_controller();
extern int vme_intset();
extern int vme_intclr();
extern void disable_intr();
extern void enable_intr();

/* Flash the i/o pipe line */

#define EIEIO	asm("eieio")
#ifndef SYNC
#define SYNC	asm("sync")
#endif

/* ====================================================================== */
/* Standard driver interfaces                                             */

void  IntrHandler();
char *LrfscDrvrInstall();
int   LrfscDrvrUninstall();
int   LrfscDrvrOpen();
int   LrfscDrvrClose();
int   LrfscDrvrIoctl();
int   LrfscDrvrRead();
int   LrfscDrvrWrite();
int   LrfscDrvrSelect();

/* ====================================================================== */
/* Declare a static working area global pointer.                          */

static LrfscDrvrWorkingArea *Wa = NULL;

/*========================================================================*/
/* Short copy                                                             */
/*========================================================================*/

void CopyWords(unsigned short *dst, unsigned short *src, int bytes) {
int i, wds;

   wds = bytes/sizeof(unsigned short);
   for (i=0; i<wds; i++) dst[i] = src[i];
}

/*========================================================================*/
/* Cancel a timeout in a safe way                                         */
/*========================================================================*/

static void CancelTimeout(t)
int *t; {

int ps,v;

   disable(ps);
   {
      if ((v = *t)) {
	 *t = 0;
	 cancel_timeout(v);
      }
   }
   restore(ps);
}

/* ====================================================================== */
/* Raw IO                                                                 */
/* ====================================================================== */

#define READ_FLAG 0
#define WRITE_FLAG 1

static int RawIo(LrfscDrvrModuleContext *mcon,
		 LrfscDrvrRawIoBlock    *riob,
		 int rwflg) {

volatile LrfscDrvrModuleAddress *moad; /* Module address, vector, level, ssch */
volatile unsigned short         *mmap; /* Module Memory map */
unsigned short                  *uary;
int                             i, j, rval;

   moad = &(mcon->Address);
   if (riob->RamFlag) mmap = moad->RamAddress;
   else               mmap = moad->VMEAddress;
   uary = riob->UserArray;
   rval = OK;

   if (!recoset()) {         /* Catch bus errors */
      for (i=0; i<riob->Size; i++) {
	 j = riob->Offset+i;
	 if (rwflg) mmap[j] = uary[i];
	 else       uary[i] = mmap[j];
	 EIEIO;
	 SYNC;
      }
   } else {
      noreco();

      cprintf("LrfscDrvr: BUS-ERROR: Module:%d Offset:0x%X Address:0x%X ",
	      (int) mcon->ModuleIndex+1,
	      (int) j,
	      (int) &(mmap[j]));

      if (riob->RamFlag) cprintf("RAM\n");
      else               cprintf("REG\n");

      pseterr(ENXIO);
      return SYSERR;
   }
   noreco();
   return riob->Size;
}

/* ====================================================================== */
/* Convert Time IQ value to Time IQ increment                             */
/* Result is stored in the module context                                 */
/* ====================================================================== */

int IQValToInc(LrfscDrvrModuleContext *mcon, LrfscDrvrConfigBuf *buf) {

LrfscDrvrConfigArray *mcdst;        /* Module Context Configuration array */
LrfscDrvrConfigPoint  pi, *p1, *p2; /* Initial, (n)th, (n+1)th */

LrfscDrvrVector      *vec;          /* Vector */
LrfscDrvrVectorArray *va;           /* Vector array */

int i;

float fI, fQ, fT;

   if ((buf->Points > LrfscDrvrCONFIG_POINTS)
   ||  (buf->Which  > LrfscDrvrCONFIGS)
   ||  (buf->Cycle  > LrfscDrvrCYCLES)) {

      pseterr(EINVAL);
      return SYSERR;
   }

   /* Keep a copy of the unconverted user array in the module context */

   mcdst = &((*mcon).Configs[(int) buf->Which][(int) buf->Cycle]);
   bcopy((void *) buf->Array, (void *) mcdst, sizeof(LrfscDrvrConfigArray));

   /* Target vector array to receive conversion */

   va =&((*mcon).Vectors[(int) buf->Which][(int) buf->Cycle]);
   vec = &((*va)[0]);

   p2 = &(buf->Array[0]);                /* First array entry */
   pi = *p2;                             /* Initial value */

   vec->Next  = sizeof(LrfscDrvrVector)/2;
   vec->Ticks = 1;                       /* Initial increment */
   vec->IncI.Long = (int) pi.IQ.I << 16;
   vec->IncQ.Long = (int) pi.IQ.Q << 16;

   for (i=1; i<buf->Points; i++) {

      vec = &((*va)[i]);

      p1 = p2;
      p2 = &(buf->Array[i]);

      fT = (float) p2->Ticks - p1->Ticks;
      if (fT > 0) {
	 fI = (float) ((p2->IQ.I - p1->IQ.I) / fT) * (float) 0x10000;
	 fQ = (float) ((p2->IQ.Q - p1->IQ.Q) / fT) * (float) 0x10000;

	 vec->Next      = (i+1) * (sizeof(LrfscDrvrVector)/2);
	 vec->IncI.Long = (int) fI;
	 vec->IncQ.Long = (int) fQ;
	 vec->Ticks     = (int) fT;
      } else {
	 pseterr(EINVAL);
	 return SYSERR;
      }
   }

   if (buf->Flag == LrfscDrvrFunctionREPEAT) {
      vec            = &((*va)[i]);
      vec->Next      = 0;
      vec->IncI.Long = (int) (pi.IQ.I - p2->IQ.I) << 16;
      vec->IncQ.Long = (int) (pi.IQ.Q - p2->IQ.Q) << 16;
      vec->Ticks     = 1;
      i++;
   }
   vec = &((*va)[i]);
   vec->Next      = 0;
   vec->Ticks     = 0xFFFF;
   vec->IncI.Long = 0;
   vec->IncQ.Long = 0;

   return OK;
}

/* ====================================================================== */
/* Convert Time IQ increment to Time IQ value                             */
/* Result is stored in the module config buf                              */
/* ====================================================================== */

int IncToIQVal(LrfscDrvrModuleContext *mcon, LrfscDrvrConfigBuf *buf) {

LrfscDrvrConfigArray *mcsrc;        /* Module Context Configuration array */

   if ((buf->Points > LrfscDrvrCONFIG_POINTS)
   ||  (buf->Which  > LrfscDrvrCONFIGS)
   ||  (buf->Cycle  > LrfscDrvrCYCLES)) {

      pseterr(EINVAL);
      return SYSERR;
   }

   mcsrc = &((*mcon).Configs[(int) buf->Which][(int) buf->Cycle]);
   bcopy((void *) mcsrc, (void *) buf->Array, sizeof(LrfscDrvrConfigArray));

   return OK;
}

/* ====================================================================== */
/* Set a configuration on a module                                        */
/* ====================================================================== */

static int SetConfiguration(LrfscDrvrModuleContext *mcon, LrfscDrvrConfig cnf, int cyc) {

volatile LrfscDrvrModuleAddress *moad;        /* Module address, vector, level */
volatile LrfscDrvrMemoryMap     *mmap;        /* Module Memory map */
volatile LrfscDrvrVector        *dst;
LrfscDrvrVector                 *src;

int i, ps;
unsigned short old;

   disable(ps);
   {
      moad = &(mcon->Address);
      mmap  = (LrfscDrvrMemoryMap *) moad->VMEAddress;

      old = mmap->RamSelect;
      mmap->RamSelect = (unsigned short) cnf;

      EIEIO;
      SYNC;

      src = &((*mcon).Vectors[(int) cnf][(int) cyc][0]);

      dst = (volatile LrfscDrvrVector *)
	    ( (unsigned long) moad->RamAddress
	  |   (unsigned long) ((cyc & 31) << 14) );

      for (i=0; i<LrfscDrvrCONFIG_POINTS; i++) {
	 dst->Next              = src->Next;
	 dst->Ticks             = src->Ticks;
	 dst->IncI.Shorts.High  = src->IncI.Shorts.High;
	 dst->IncI.Shorts.Low   = src->IncI.Shorts.Low;
	 dst->IncQ.Shorts.High  = src->IncQ.Shorts.High;
	 dst->IncQ.Shorts.Low   = src->IncQ.Shorts.Low;
	 if (dst->Next == 0) break;
	 dst++; src++;
      }
      mmap->RamSelect = old;
   }
   restore(ps);
   return OK;
}

/* ====================================================================== */
/* Set coefficients on a module                                           */
/* ====================================================================== */

static int SetMatrixCoefficient(LrfscDrvrModuleContext *mcon, LrfscDrvrMatrix mnm) {

volatile LrfscDrvrModuleAddress *moad;        /* Module address, vector, level */
volatile LrfscDrvrMemoryMap     *mmap;        /* Module Memory map */
LrfscDrvrMatrixCoefficients *mat;

   moad = &(mcon->Address);
   mmap = (LrfscDrvrMemoryMap *) moad->VMEAddress;
   mat  = &(mcon->Coefficients[(int) mnm]);
   CopyWords((unsigned short *) &(mmap->Matrix[(int) mnm]),
	     (unsigned short *) mat,
	     sizeof(LrfscDrvrMatrixCoefficients));
   return OK;
}

/* ====================================================================== */
/* Set signal choice on a module                                          */
/* ====================================================================== */

static int SetSignalChoice(LrfscDrvrModuleContext *mcon, int sgn) {

volatile LrfscDrvrModuleAddress *moad;        /* Module address, vector, level */
volatile LrfscDrvrMemoryMap     *mmap;        /* Module Memory map */

   moad = &(mcon->Address);
   mmap = (LrfscDrvrMemoryMap *) moad->VMEAddress;
   mmap->SignalChoices[sgn] = (unsigned short) mcon->SignalChoices[sgn];
   return OK;
}

/* ====================================================================== */
/* Reset the module to known state                                        */
/* ====================================================================== */

static int Reset(LrfscDrvrModuleContext *mcon) {

volatile LrfscDrvrModuleAddress *moad;        /* Module address, vector, level */
volatile LrfscDrvrMemoryMap     *mmap;        /* Module Memory map */
int                              i,j;

   moad = &(mcon->Address);
   mmap  = (LrfscDrvrMemoryMap *) moad->VMEAddress;
   if (!recoset()) {

      mmap->State = (unsigned short) LrfscDrvrStateCONFIG;
      EIEIO;
      SYNC;

      for (i=0; i<LrfscDrvrDiagSIGNAL_CHOICES; i++) SetSignalChoice(mcon, i);
      for (i=0; i<LrfscDrvrMatrixMATRICES; i++) SetMatrixCoefficient(mcon, (LrfscDrvrMatrix) i);
      for (i=0; i<LrfscDrvrCONFIGS; i++) {
	 mmap->RamSelect = (unsigned short) i;
	 for (j=0; j<LrfscDrvrCYCLES; j++) SetConfiguration(mcon, (LrfscDrvrConfig) i, j);
      }

      mmap->Control            = (unsigned short) mcon->Control;
      mmap->Vector             = (unsigned short) moad->InterruptVector;
      mmap->RamSelect          = (unsigned short) mcon->RamSelect;
      mmap->ResCtrl.Time       = (unsigned short) mcon->ResCtrl.Time;
      mmap->ResCtrl.Value      = (unsigned short) mcon->ResCtrl.Value;
      mmap->SwitchCtrl         = (unsigned short) mcon->SwitchCtrl;
      mmap->SoftSwitch         = (unsigned short) mcon->SoftSwitch;
      mmap->SnapShot.DiagTime  = (unsigned short) mcon->DiagTime;
      mmap->Pic.KP             = (  signed short) mcon->Pic.KP;
      mmap->Pic.KI             = (  signed short) mcon->Pic.KI;
      mmap->NextCycle          = (unsigned short) 0;
      mmap->RfOnMaxLen         = (unsigned short) mcon->RfOnMaxLen;
      mmap->State              = (unsigned short) mcon->State;
      EIEIO;
      SYNC;

   } else {
      noreco();
      cprintf("LrfscDrvr: BUS-ERROR: Module:%d. VME Addr:%x Vect:%x Level:%x\n",
	      mcon->ModuleIndex+1,
	      moad->VMEAddress,
	      moad->InterruptVector,
	      moad->InterruptLevel);

      pseterr(ENXIO); /* No such device or address */
      return SYSERR;
   }
   noreco();
   return OK;
}

/* ====================================================================== */
/* Add a module to the driver, called per module from install             */
/* ====================================================================== */

static int AddModule(LrfscDrvrModuleContext *mcon, unsigned long index) {

volatile LrfscDrvrModuleAddress *moad; /* Module address, vector, level, ssch */
volatile LrfscDrvrMemoryMap     *mmap; /* Module Memory map */
unsigned long                    addr; /* VME base address */
unsigned long                    coco; /* Completion code */

LrfscDrvrVector                 *vec;  /* Vector */
LrfscDrvrVectorArray            *va;   /* Vector array */

struct pdparam_master param;
volatile short *vmeaddr;
volatile short *ramaddr;

unsigned short wrd;
int cy;

#if 0
LrfscDrvrMemoryMap *pmap;
   pmap = NULL;
   cprintf("IrqSource    %03d 0x%08X \n",(int) &(pmap->IrqSource    ),  (int) &(pmap->IrqSource    ));
   cprintf("SignalChoice %03d 0x%08X \n",(int) &(pmap->SignalChoices),  (int) &(pmap->SignalChoices));
   cprintf("ResCtrl      %03d 0x%08X \n",(int) &(pmap->ResCtrl      ),  (int) &(pmap->ResCtrl      ));
   cprintf("Matrix       %03d 0x%08X \n",(int) &(pmap->Matrix       ),  (int) &(pmap->Matrix       ));
   cprintf("SnapShot     %03d 0x%08X \n",(int) &(pmap->SnapShot     ),  (int) &(pmap->SnapShot     ));
   cprintf("Pic          %03d 0x%08X \n",(int) &(pmap->Pic          ),  (int) &(pmap->Pic          ));
   cprintf("RfOffTime    %03d 0x%08X \n",(int) &(pmap->RfOffTime    ),  (int) &(pmap->RfOffTime    ));
   cprintf("VhdlVerH     %03d 0x%08X \n",(int) &(pmap->VhdlVerH     ),  (int) &(pmap->VhdlVerH     ));
   cprintf("Status       %03d 0x%08X \n",(int) &(pmap->Status       ),  (int) &(pmap->Status       ));
   cprintf("RfOnMaxLen   %03d 0x%08X \n",(int) &(pmap->RfOnMaxLen   ),  (int) &(pmap->RfOnMaxLen   ));
#endif

   /* Compute Virtual memory address as seen from system memory mapping */

   moad = &(mcon->Address);

   /* CES: build an address window (64 kbyte) for VME A24-D16 accesses */

   addr = (unsigned long) moad->VMEAddress;
   addr &= 0x007fffff;                      /* A24 - Bit-19 */

   bzero((char *)&param, sizeof(struct pdparam_master));

   param.iack   = 1;     /* no iack */
   param.rdpref = 0;     /* no VME read prefetch option */
   param.wrpost = 0;     /* no VME write posting option */
   param.swap   = 1;     /* VME auto swap option */
   param.dum[0] = 0;     /* window is sharable */

   vmeaddr = (void *) find_controller(addr,    /* Vme base address */
				      0x10000, /* Module address space */
				      0x39,    /* Address modifier A24 */
				      0,       /* Offset */
				      2,       /* Size is D16 */
				      &param); /* Parameter block */
   if (vmeaddr == (void *) (-1)) {
      cprintf("LrfscDrvr: find_controller: ERROR: Module:%d. VME Addr:%x\n",
	      index+1,
	      addr);

      pseterr(ENXIO);        /* No such device or address */
      return SYSERR;
   }
   moad->VMEAddress = (unsigned short *) vmeaddr;

   mmap  = (LrfscDrvrMemoryMap *) moad->VMEAddress;

   mmap->State = (unsigned short) 0; /* Interrupts off/Config mode */
   wrd = mmap->IrqSource;            /* Clear interrup register */

   addr |= LrfscDrvrSTART_OF_RAM;
   ramaddr = (void *) find_controller(addr,    /* Vme RAM base address */
				      LrfscDrvrTOTAL_RAM_SIZE, /* Module address space */
				      0x39,                    /* Address modifier A24 */
				      0,                       /* Offset */
				      2,                       /* Size is D16 */
				      &param);                 /* Parameter block */
   if (ramaddr == (void *) (-1)) {
      cprintf("LrfscDrvr: find_controller: ERROR: Module:%d. RAM Addr:%x\n",
	      index+1,
	      addr);

      pseterr(ENXIO); /* No such device or address */
      return SYSERR;
   }
   moad->RamAddress = (unsigned short *) ramaddr;

   if (!recoset()) {
      wrd = (unsigned short) *ramaddr;
      EIEIO;
      SYNC;

   } else {
      noreco();
      cprintf("LrfscDrvr: BUS-ERROR: Module:%d. RAM Addr:%x Vect:%x Level:%x\n",
	      mcon->ModuleIndex+1,
	      moad->RamAddress,
	      moad->InterruptVector,
	      moad->InterruptLevel);

      pseterr(ENXIO); /* No such device or address */
      return SYSERR;
   }
   noreco();

   coco = vme_intset((moad->InterruptVector),  /* Vector */
		     (void *) IntrHandler,     /* Address of ISR */
		     (char *) mcon,            /* Parameter to pass */
		      0);                      /* Don't save previous */
   if (coco < 0) {
      cprintf("LrfscDrvr: vme_intset: ERROR %d, MODULE %d\n",coco,index+1);
      pseterr(EFAULT);
      return SYSERR;
   }

   mcon->ModuleIndex             = index;
   mcon->State                   = LrfscDrvrStateCONFIG;
   mcon->Control                 = LrfscDrvrControlNONE;
   mcon->RamSelect               = LrfscDrvrRamSETPOINTS;
   mcon->ResCtrl.Time            = 0xFF;
   mcon->SwitchCtrl              = 0;
   mcon->SoftSwitch              = LrfscDrvrSotfSwitchMAIN_CLOSED;
   mcon->DiagTime                = 10000;
   mcon->RfOnMaxLen              = 0xFFFF;
   mcon->Pic.KI                  = 246;
   mcon->Pic.KP                  = 640;
   mcon->SignalChoices[0]        = LrfscDrvrDiagCAVITY;
   mcon->SignalChoices[1]        = LrfscDrvrDiagFORWARD;
   mcon->SignalChoices[2]        = LrfscDrvrDiagREFLECTED;
   mcon->SignalChoices[3]        = LrfscDrvrDiagOUTPUT;
   mcon->Coefficients[0].MatrixA = 0xED2C;
   mcon->Coefficients[0].MatrixB = 0x0EC6;
   mcon->Coefficients[0].MatrixC = 0xF13A;
   mcon->Coefficients[0].MatrixD = 0xED2C;
   mcon->Coefficients[1].MatrixA = 0xED2C;
   mcon->Coefficients[1].MatrixB = 0x0EC6;
   mcon->Coefficients[1].MatrixC = 0xF13A;
   mcon->Coefficients[1].MatrixD = 0xED2C;
   mcon->Coefficients[2].MatrixA = 0xED2C;
   mcon->Coefficients[2].MatrixB = 0x0EC6;
   mcon->Coefficients[2].MatrixC = 0xF13A;
   mcon->Coefficients[2].MatrixD = 0xED2C;

   for (cy=0; cy<LrfscDrvrCYCLES; cy++) {

      va              = &((*mcon).Vectors[LrfscDrvrConfigSETPOINTS][cy]);
      vec             = &((*va)[0]);
      vec->Next       = sizeof(LrfscDrvrVector)/2;
      vec->Ticks      = 1;
      vec->IncI.Long  = 4000 << 16;
      vec->IncQ.Long  = 0;

      vec             = &((*va)[1]);
      vec->Next       = 0;
      vec->Ticks      = 0xFFFF;
      vec->IncI.Long  = 0;
      vec->IncQ.Long  = 0;

      va              = &((*mcon).Vectors[LrfscDrvrConfigFEEDFORWARD][cy]);
      vec             = &((*va)[0]);
      vec->Next       = 0;
      vec->Ticks      = 0xFFFF;
      vec->IncI.Long  = 0;
      vec->IncQ.Long  = 0;
   }

   return Reset(mcon);
}

/* ====================================================================== */
/* Connect to an interrupt                                                */
/* ====================================================================== */

static int Connect(LrfscDrvrConnection *conx,
		   LrfscDrvrClientContext *ccon) {

LrfscDrvrModuleContext *mcon;
int modi = 0;
int clni;

   if (conx->Module) modi = conx->Module -1;
   mcon = &(Wa->ModuleContexts[modi]);
   if (mcon->State == LrfscDrvrStateCONFIG) {
      pseterr(EBUSY); /* Device busy, in local */
      return SYSERR;
   }

   clni = ccon->ClientIndex;
   mcon->Clients[clni] |= conx->Interrupt;
   if ((conx->Interrupt & LrfscDrvrInterruptPULSE) != 0)
      ccon->Pulse = conx->Pulse;

   return OK;
}

/* ====================================================================== */
/* Disconnect from module interrupts                                      */
/* ====================================================================== */

static int DisConnect(LrfscDrvrConnection *conx,
		      LrfscDrvrClientContext *ccon) {

LrfscDrvrModuleContext *mcon;
int modi = 0;
int clni;

   if (conx->Module) modi = conx->Module -1;
   mcon = &(Wa->ModuleContexts[modi]);

   clni = ccon->ClientIndex;
   mcon->Clients[clni] &= ~conx->Interrupt;
   if ((mcon->Clients[clni] & LrfscDrvrInterruptPULSE) == 0)
      ccon->Pulse = 0;
   return OK;
}

/* ====================================================================== */
/* Interrupt handler                                                      */
/* ====================================================================== */

void IntrHandler(LrfscDrvrModuleContext *mcon) {

volatile LrfscDrvrMemoryMap     *mmap;
LrfscDrvrClientContext          *ccon;
LrfscDrvrClientQueue            *queue;
LrfscDrvrConnection              rb;
unsigned int                     i,j,iq,ci,si,vd,skpstr,skpcnt;
unsigned short                   isrc, csrc, pnum, cnum;
LrfscDrvrDiagSignalChoice        sigc;
LrfcsDrvrRamIqArray             *ram;
LrfscDrvrIQPair                 *src, *dst;

   mmap =  (LrfscDrvrMemoryMap  *) mcon->Address.VMEAddress;
   ram  =  (LrfcsDrvrRamIqArray *) mcon->Address.RamAddress;

   isrc = mmap->IrqSource;
   cnum = mmap->PresCycle;
   pnum = mmap->PulseNumber;

   bzero((void *) &rb, sizeof(LrfscDrvrConnection));
   rb.Module = mcon->ModuleIndex + 1;

   while (isrc) {
      for (ci=0; ci<LrfscDrvrCLIENT_CONTEXTS; ci++) {
	 ccon = &(Wa->ClientContexts[ci]);
	 if (ccon->InUse) {
	    csrc = isrc & mcon->Clients[ci];
	    if (csrc & LrfscDrvrInterruptPULSE) {
	       if ((ccon->Pulse == 0) || (pnum == ccon->Pulse)) {
		  rb.Pulse = pnum;
		  rb.Interrupt |= LrfscDrvrInterruptPULSE;
	       }
	    }
	    if (csrc & LrfscDrvrInterruptSTART_CYCLE)
	       rb.Interrupt |= LrfscDrvrInterruptSTART_CYCLE;
	 }

	 if (rb.Interrupt) {
	    queue = &(ccon->Queue);
	    if (queue->Size < LrfscDrvrCLIENT_QUEUE_SIZE) {
	       queue->Size++;
	       iq = queue->Head;
	       queue->Queue[iq++] = rb;
	       ssignal(&(ccon->Semaphore));
	       if (iq < LrfscDrvrCLIENT_QUEUE_SIZE) queue->Head = iq;
	       else                                 queue->Head = 0;
	    } else {
	       queue->Missed++;
	    }
	    rb.Interrupt = 0;
	    rb.Pulse     = 0;
	 }
      }

      if (isrc & LrfscDrvrInterruptPULSE) {
	 for (si=0; si<LrfscDrvrDiagSIGNAL_CHOICES; si++) {
	    sigc = (LrfscDrvrDiagSignalChoice) (unsigned short) mmap->SignalChoices[si];
	    skpstr = mcon->SkipStart;
	    skpcnt = mcon->SkipCount;
	    if (skpcnt == 0) skpcnt = (mmap->SnapShot.DiagTime/LrfscDrvrSKP_FACTOR);
	    if ((mcon->Pulse == pnum) && (mcon->State == LrfscDrvrStatePROD_REMOTE)) {
	       mmap->RamSelect = (unsigned short) (LrfscDrvrRamSelection) si + LrfscDrvrRamDIAG1;
	       for (i=skpstr, j=0; j<LrfscDrvrBUF_IQ_ENTRIES; i+=skpcnt, j++) {
		  dst = &(mcon->Diags[sigc][cnum])[j];
		  src = &((*ram)[i]);
		  dst->I = src->I;
		  dst->Q = src->Q;
		  vd = 1;
	       }
	    } else vd = 0;
	    mcon->ValidDiags[sigc][cnum] = vd;
	 }
      }
      isrc = mmap->IrqSource;
      pnum = mmap->PulseNumber;
      cnum = mmap->PresCycle;
   }
}

/***************************************************************************/
/* INSTALL                                                                 */
/***************************************************************************/

char *LrfscDrvrInstall(LrfscDrvrInfoTable *info) {

int                              i, count;
LrfscDrvrModuleContext          *mcon;     /* Module context */
volatile LrfscDrvrModuleAddress *moad;     /* Modules address */
LrfscDrvrWorkingArea            *wa;

   /*Allocate the driver working area*/

   cprintf("Lrfsc: Sizeof Working Area:0x%08X[%d]\n",
	   sizeof(LrfscDrvrWorkingArea),
	   sizeof(LrfscDrvrWorkingArea));
   cprintf("Lrfsc: Sizeof Module Context:0x%08X[%d]\n",
	   sizeof(LrfscDrvrModuleContext),
	   sizeof(LrfscDrvrModuleContext));
   cprintf("Lrfsc: Sizeof Client Context:0x%08X[%d]\n",
	   sizeof(LrfscDrvrClientContext),
	   sizeof(LrfscDrvrClientContext));
   cprintf("Lrfsc: Sizeof Vector Array:0x%08X[%d]\n",
	   sizeof(LrfscDrvrVectorArray),
	   sizeof(LrfscDrvrVectorArray));

   wa = (LrfscDrvrWorkingArea *) sysbrk(sizeof(LrfscDrvrWorkingArea));
   if (!wa) {
      cprintf("LrfscDrvrInstall: NOT ENOUGH MEMORY(WorkingArea)\n");
      pseterr(ENOMEM);          /* Not enough core */
      return((char *) SYSERR);
   }
   Wa = wa;                     /* Global working area pointer */

   /****************************************/
   /* Initialize the driver's working area */
   /* and add the modules ISR into LynxOS  */
   /****************************************/

   bzero((void *) wa, sizeof(LrfscDrvrWorkingArea));       /* Clear working area */

   count = 0;
   for (i=0; i<info->Modules; i++) {
      mcon  = &(wa->ModuleContexts[i]);
      moad  = &(mcon->Address);
      *moad = info->Addresses[i];

      if (AddModule(mcon,count) != OK) {
	 cprintf("LrfscDrvr: Module: %d Not Installed\n", i+1);
	 bzero((void *) moad,sizeof(LrfscDrvrModuleAddress));     /* Wipe it out */
      } else {
	 count++;
	 mcon->ModuleIndex = count -1;
	 cprintf("LrfscDrvr: Module %d. VME Addr: %x RAM Addr: %x Vect: %x Level: %x Installed OK\n",
		 count,
		 moad->VMEAddress,
		 moad->RamAddress,
		 moad->InterruptVector,
		 moad->InterruptLevel);
      }

   }
   wa->Modules = count;
   cprintf("LrfscDrvr: Installed: %d LRFSC Modules in Total\n",count);
   return((char*) wa);
}

/***************************************************************************/
/* UNINSTALL                                                               */
/***************************************************************************/

int LrfscDrvrUninstall(wa)
LrfscDrvrWorkingArea * wa; {     /* Drivers working area pointer */

   cprintf("LrfscDrvr: ERROR: UnInstall capabilities are not supported\n");

   /* EPERM = "Operation not permitted" */

   pseterr(EPERM);             /* Not supported */
   return SYSERR;

}

/***************************************************************************/
/* OPEN                                                                    */
/***************************************************************************/

int LrfscDrvrOpen(wa,dnm,flp)
LrfscDrvrWorkingArea *wa;
int dnm;
struct file *flp; {

LrfscDrvrClientContext *ccon; /* Client context */
int                     cnum; /* Client number */

   /* We allow one client per minor device, we use the minor device */
   /* number as an index into the client contexts array. */

   cnum = minor(flp->dev) -1;
   if ((cnum < 0) || (cnum >= LrfscDrvrCLIENT_CONTEXTS)) {

      /* EFAULT = "Bad address" */

      pseterr(EFAULT);
      return SYSERR;
   }
   ccon = &(wa->ClientContexts[cnum]);


   /* If already open by someone else, give a permission denied error */

   if (ccon->InUse) {

      /* This next error is normal */
      /* EBUSY = "Resource busy" */

      pseterr(EBUSY);           /* File descriptor already open */
      return SYSERR;
   }

   /* Initialize a client context */

   bzero((void *) ccon,(long) sizeof(LrfscDrvrClientContext));
   ccon->ClientIndex = cnum;
   ccon->Timeout     = LrfscDrvrDEFAULT_TIMEOUT;
   ccon->InUse       = 1;
   ccon->Pid         = getpid();
   return OK;
}

/***************************************************************************/
/* CLOSE                                                                   */
/***************************************************************************/

int LrfscDrvrClose(wa, flp)
LrfscDrvrWorkingArea * wa;          /* Working area */
struct file * flp; {               /* File pointer */

int cnum;                          /* Client number */

LrfscDrvrModuleContext     * mcon;   /* Module context */
LrfscDrvrClientContext     * ccon;   /* Client context */

   /* We allow one client per minor device, we use the minor device */
   /* number as an index into the client contexts array.            */

   cnum = minor(flp->dev) -1;
   if ((cnum < 0) || (cnum >= LrfscDrvrCLIENT_CONTEXTS)) {

      /* EFAULT = "Bad address" */

      pseterr(EFAULT);
      return SYSERR;
   }
   ccon = &(Wa->ClientContexts[cnum]);

   /* Cancel any pending timeouts */
   /* Disconnect this client from events */

   CancelTimeout(&ccon->Timer);
   mcon->Clients[ccon->ClientIndex] = 0;

   /* Wipe out the client context */

   bzero((void *) ccon,sizeof(LrfscDrvrClientContext));
   return(OK);
}

/***************************************************************************/
/* IOCTL                                                                   */
/***************************************************************************/

int LrfscDrvrIoctl(wa, flp, cm, arg)
LrfscDrvrWorkingArea *wa;
struct file *flp;
LrfscDrvrControlFunction cm;
char *arg; {

int cnum;                               /* Client number */
int rcnt, wcnt;                         /* Readable, Writable byte counts at arg address */
long lav;                                               /* Long value from arg */
volatile long *lap;             /* Long Value pointed to by Arg */
volatile unsigned short *sap;   /* Short IO value pointer */
unsigned short sav;                             /* Short IO value */

volatile LrfscDrvrMemoryMap     *mmap;

LrfscDrvrClientContext          *ccon;
LrfscDrvrModuleContext          *mcon;
LrfscDrvrRawIoBlock             *riob;
LrfscDrvrConnection             *conx;
LrfscDrvrDiagChoices            *diagch;
LrfscDrvrDiagSignalChoice       sigch;
LrfscDrvrResCtrl                *resctl;
LrfscDrvrAnalogSwitch           *anlgsw;
LrfscDrvrSoftSwitch             *softsw;
LrfscDrvrMatrixCoefficientsBuf  *coefbuf;
LrfscDrvrMatrix                 matrx;
LrfscDrvrDiagSnapShot           *snapsht;
LrfscDrvrPicSetBuf              *picbuff;
LrfscDrvrConfigBuf              *confbuf;
LrfscDrvrDiagBuf                *diagbuf;
LrfscDrvrVersion                *verbuf;
LrfscDrvrModuleAddress          *moadbuf;
LrfscDrvrClientList             *clsbuf;
LrfscDrvrClientConnections      *ccnbuf;
LrfscDrvrIQPair                 *src, *dst;

int i, j, err, cynum, size;

   /* Check argument contains a valid address for reading or writing. */
   /* We can not allow bus errors to occur inside the driver due to   */
   /* the caller providing a garbage address in "arg". So if arg is   */
   /* not null set "rcnt" and "wcnt" to contain the byte counts which */
   /* can be read or written to without error. */

   if (arg != NULL) {
      rcnt = rbounds((int)arg);       /* Number of readable bytes without error */
      wcnt = wbounds((int)arg);       /* Number of writable bytes without error */
      if (rcnt < sizeof(long)) {      /* We at least need to read one long */
	 cprintf("LrfscDrvrIoctl: ILLEGAL NON NULL ARG POINTER, RCNT=%d/%d\n",
		 rcnt,sizeof(long));
	 pseterr(EINVAL);          /* Invalid argument */
	 return SYSERR;
      }
      lav = *((long *) arg);       /* Long argument value */
      lap =   (long *) arg ;       /* Long argument pointer */
   } else {
      rcnt = 0; wcnt = 0; lav = 0; lap = NULL; /* Null arg = zero read/write counts */
   }

   /* We allow one client per minor device, we use the minor device */
   /* number as an index into the client contexts array. */

   cnum = minor(flp->dev) -1;
   if ((cnum < 0) || (cnum >= LrfscDrvrCLIENT_CONTEXTS)) {
      pseterr(ENODEV);          /* No such device */
      return SYSERR;
   }

   /* We can't control a file which is not open. */

   ccon = &(wa->ClientContexts[cnum]);
   if (ccon->InUse == 0) {
      cprintf("LrfscDrvrIoctl: DEVICE %2d IS NOT OPEN\n",cnum+1);
      pseterr(EBADF);           /* Bad file number */
      return SYSERR;
   }

   mcon = &(wa->ModuleContexts[ccon->ModuleIndex]); /* Default module selected */
   mmap =  (LrfscDrvrMemoryMap     *) mcon->Address.VMEAddress;

   /*************************************/
   /* Decode callers command and do it. */
   /*************************************/

   switch (cm) {

      case LrfscDrvrSET_MODULE:              /* Select the module to work with */
	 if ((lav >= 1) &&  (lav <= Wa->Modules)) {
		 ccon->ModuleIndex = lav -1;
		 return OK;
	 }
      break;

      case LrfscDrvrGET_MODULE:
	 if (lap) {
		 *lap = ccon->ModuleIndex +1;
		 return OK;
	 }
      break;

      case LrfscDrvrGET_MODULE_COUNT:
	 if (lap) {
	    *lap = Wa->Modules;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_MODULE_ADDRESS:       /* LrfscDrvrModuleAddress Read */
	 if (wcnt >= sizeof(LrfscDrvrModuleAddress)) {
	    moadbuf = (LrfscDrvrModuleAddress *) arg;
	    *moadbuf = mcon->Address;
	    return OK;
	 }
      break;

      case LrfscDrvrRESET:
	 return Reset(mcon);

      case LrfscDrvrGET_STATUS:               /* LrfscDrvrStatus Get status */
	 if (lap) {
		 sav = mmap->Status;
		 *lap = (unsigned long) sav;
		 return OK;
	 }
      break;

      case LrfscDrvrSET_SW_DEBUG:             /* ulong Set software debug level */
	 if (lap) {
	    ccon->Debug = lav;
	    if (lav) cprintf("lrfsc driver:Debug level:%d on\n", (int) lav);
	    else     cprintf("lrfsc driver:Debug off\n");
	    return OK;
	 }
      break;

      case LrfscDrvrGET_SW_DEBUG:             /* ulong Get software debug level */
	 if (lap) {
	    *lap = ccon->Debug;
	    return OK;
	 }
      break;

      case LrfscDrvrRAW_READ:         /* LrfscDrvrRawIoBlock Read  */
	 if (rcnt >= sizeof(LrfscDrvrRawIoBlock)) {
	    riob = (LrfscDrvrRawIoBlock *) arg;
	    RawIo(mcon, riob, READ_FLAG);
	    return OK;
	 }
      break;

      case LrfscDrvrRAW_WRITE:        /* LrfscDrvrRawIoBlock Write */
	 if (rcnt >= sizeof(LrfscDrvrRawIoBlock)) {
	    riob = (LrfscDrvrRawIoBlock *) arg;
	    RawIo(mcon, riob, WRITE_FLAG);
	    return OK;
	 }
      break;

      case LrfscDrvrSET_TIMEOUT:              /* ulong Set read timeout */
	 if (lap) {
	    ccon->Timeout = lav;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_TIMEOUT:              /* ulong Get read timeout */
	 if (lap) {
	    *lap = ccon->Timeout;
	    return OK;
	 }
      break;

      case LrfscDrvrCONNECT:
	 if (rcnt >= sizeof(LrfscDrvrConnection)) {
	    conx = (LrfscDrvrConnection *) arg;
	    if (conx->Interrupt) return Connect(conx, ccon);
	 }
	 break;

      case LrfscDrvrDISCONNECT:
	 if (rcnt >= sizeof(LrfscDrvrConnection)) {
	    conx = (LrfscDrvrConnection *) arg;
	    if (conx->Interrupt == 0) conx->Interrupt = LrfscDrvrINTERUPT_MASK;
	    return DisConnect(conx, ccon);
	 }
      break;

      case LrfscDrvrSET_QUEUE_FLAG:           /* ulong Set queue off 1 or on 0 */
	 if (lap) {
	    ccon->Queue.QOff = lav;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_QUEUE_FLAG:
	 if (lap) {
	    *lap = ccon->Queue.QOff;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_QUEUE_SIZE:
	 if (lap) {
	    *lap = ccon->Queue.Size;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_QUEUE_OVERFLOW:
	 if (lap) {
	    *lap = ccon->Queue.Missed;
	    ccon->Queue.Missed = 0;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_CLIENT_LIST:                  /* LrfscDrvrClientList Get all clients */
	 if (wcnt >= sizeof(LrfscDrvrClientList)) {
	    clsbuf = (LrfscDrvrClientList *) arg;
	    bzero((void *) clsbuf, sizeof(LrfscDrvrClientList));
	    for (i=0; i<LrfscDrvrCLIENT_CONTEXTS; i++) {
	       ccon = &(wa->ClientContexts[i]);
	       if (ccon->InUse) clsbuf->Pid[clsbuf->Size++] = ccon->Pid;
	    }
	    return OK;
	 }
      break;

      case LrfscDrvrGET_CLIENT_CONNECTIONS:   /* LrfscDrvrClientConnections Get clients connections */
	 if (wcnt >= sizeof(LrfscDrvrClientConnections)) {
	    ccnbuf = (LrfscDrvrClientConnections *) arg;
	    ccnbuf->Size = 0; size = 0;
	    for (i=0; i<LrfscDrvrCLIENT_CONTEXTS; i++) {
	       ccon = &(wa->ClientContexts[i]);
	       if ((ccon->InUse) && (ccon->Pid == ccnbuf->Pid)) {
		  for (j=0; j<Wa->Modules; j++) {
		     mcon = &(Wa->ModuleContexts[j]);
		     if (mcon->Clients[i]) {
			ccnbuf->Connections[size].Module    = j+1;
			ccnbuf->Connections[size].Interrupt = mcon->Clients[i];
			ccnbuf->Connections[size].Pulse     = ccon->Pulse;
			ccnbuf->Size = ++size;
		     }
		  }
	       }
	    }
	    return OK;
	 }
      break;

      case LrfscDrvrSET_STATE:                        /* LrfscDrvrState Get Module state */
	 if (lap) {
	    sap = &(mmap->State);
	    sav = (unsigned short) *lap;
	    if (sav < LrfscDrvrSTATES) {
	       *sap = sav;
	       mcon->State = (LrfscDrvrState) sav;
	       return OK;
	    }
	 }
      break;

      case LrfscDrvrGET_STATE:
	 if (lap) {
	    sap = &(mmap->State);
	    sav = *sap;
	    if (sav >= LrfscDrvrSTATES) {
	       *sap = (unsigned short ) LrfscDrvrStateCONFIG;
	       mcon->State = LrfscDrvrStateCONFIG;
	    }
	    *lap = (unsigned long) sav;
	    return OK;
	 }
      break;

      case LrfscDrvrSET_DIAG_CHOICE:          /* Configure diagnostics channels */
	 if (rcnt >= sizeof(LrfscDrvrDiagChoices)) {
	    diagch = (LrfscDrvrDiagChoices *) arg;
	    for (i=0; i<LrfscDrvrDiagSIGNAL_CHOICES; i++) {
	       sigch = *diagch[i];
	       mcon->SignalChoices[i] = sigch;
	       SetSignalChoice(mcon,i);
	    }
	    return OK;
	 }
      break;

      case LrfscDrvrGET_DIAG_CHOICE:
	 if (wcnt >= sizeof(LrfscDrvrDiagChoices)) {
	    diagch = (LrfscDrvrDiagChoices *) arg;
	    for (i=0; i<LrfscDrvrDiagSIGNAL_CHOICES; i++) {
	       sigch = mcon->SignalChoices[i];
	       *diagch[i] = sigch;
	    }
	    return OK;
	 }
      break;

      case LrfscDrvrSET_RES_CTRL:                     /* LrfscDrvrResCtrl Set Resonance control value */
	 if (rcnt >= sizeof(LrfscDrvrResCtrl)) {
	    resctl = (LrfscDrvrResCtrl *) arg;
	    mcon->ResCtrl = *resctl;
	    mmap->ResCtrl.Time  = (unsigned short) mcon->ResCtrl.Time;
	    mmap->ResCtrl.Value = (unsigned short) mcon->ResCtrl.Value;
	    return OK;
	 }
	 break;

      case LrfscDrvrGET_RES_CTRL:
	 if (wcnt >= sizeof(LrfscDrvrResCtrl)) {
	    resctl = (LrfscDrvrResCtrl *) arg;
	    *resctl = mcon->ResCtrl;
	    resctl->Cav.I = (unsigned short) mmap->ResCtrl.Cav.I;
	    resctl->Cav.Q = (unsigned short) mmap->ResCtrl.Cav.Q;
	    resctl->Fwd.I = (unsigned short) mmap->ResCtrl.Fwd.I;
	    resctl->Fwd.Q = (unsigned short) mmap->ResCtrl.Fwd.Q;
	    return OK;
	 }
	 break;

      case LrfscDrvrSET_ANALOGUE_SWITCH:      /* LrfscDrvrAnalogSwitch */
	 if (rcnt >= sizeof(LrfscDrvrAnalogSwitch)) {
	    anlgsw = (LrfscDrvrAnalogSwitch *) arg;
	    mcon->SwitchCtrl = *anlgsw;
	    mmap->SwitchCtrl = (unsigned short) mcon->SwitchCtrl;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_ANALOGUE_SWITCH:
	 if (wcnt >= sizeof(LrfscDrvrAnalogSwitch)) {
	    anlgsw = (LrfscDrvrAnalogSwitch *) arg;
	    *anlgsw = mcon->SwitchCtrl;
	    return OK;
	 }
      break;

      case LrfscDrvrSET_SOFT_SWITCH:          /* LrfscDrvrSoftSwitch */
	 if (rcnt >= sizeof(LrfscDrvrSoftSwitch)) {
	    softsw = (LrfscDrvrSoftSwitch *) arg;
	    mcon->SoftSwitch = *softsw;
	    mmap->SoftSwitch = (unsigned short) mcon->SoftSwitch;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_SOFT_SWITCH:
	 if (wcnt >= sizeof(LrfscDrvrSoftSwitch)) {
	    softsw = (LrfscDrvrSoftSwitch *) arg;
	    *softsw = mcon->SoftSwitch;
	    return OK;
	 }
      break;

      case LrfscDrvrSET_COEFFICIENTS:         /* LrfscDrvrMatrixCoefficientsBuf */
	 if (rcnt >= sizeof(LrfscDrvrMatrixCoefficientsBuf)) {
	    coefbuf = (LrfscDrvrMatrixCoefficientsBuf *) arg;
	    matrx = coefbuf->Matrix;
	    mcon->Coefficients[matrx] = coefbuf->Coeficients;
	    return SetMatrixCoefficient(mcon, matrx);
	 }
      break;

      case LrfscDrvrGET_COEFFICIENTS:
	 if (wcnt >= sizeof(LrfscDrvrMatrixCoefficientsBuf)) {
	    coefbuf = (LrfscDrvrMatrixCoefficientsBuf *) arg;
	    matrx = coefbuf->Matrix;
	    coefbuf->Coeficients = mcon->Coefficients[matrx];
	    return OK;
	 }
      break;

      case LrfscDrvrSET_SNAP_SHOT_TIME:       /* ulong Snapshot time */
	 if (lap) {
	    mcon->DiagTime = lav;
	    mmap->SnapShot.DiagTime = (unsigned short) mcon->DiagTime;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_SNAP_SHOTS:           /* LrfscDrvrDiagSnapShot */
	 if (wcnt >= sizeof(LrfscDrvrDiagSnapShot)) {
	    snapsht = (LrfscDrvrDiagSnapShot *) arg;
	    snapsht->DiagTime       = mmap->SnapShot.DiagTime;
	    snapsht->RefDiag.I      = mmap->SnapShot.RefDiag.I;
	    snapsht->RefDiag.Q      = mmap->SnapShot.RefDiag.Q;
	    snapsht->FwdDiag.I      = mmap->SnapShot.FwdDiag.I;
	    snapsht->FwdDiag.Q      = mmap->SnapShot.FwdDiag.Q;
	    snapsht->CavDiag.I      = mmap->SnapShot.CavDiag.I;
	    snapsht->CavDiag.Q      = mmap->SnapShot.CavDiag.Q;
	    snapsht->ErrDiag.I      = mmap->SnapShot.ErrDiag.I;
	    snapsht->ErrDiag.Q      = mmap->SnapShot.ErrDiag.Q;
	    snapsht->OutDiag.I      = mmap->SnapShot.OutDiag.I;
	    snapsht->OutDiag.Q      = mmap->SnapShot.OutDiag.Q;
	    snapsht->POutDiag.I     = mmap->SnapShot.POutDiag.I;
	    snapsht->POutDiag.Q     = mmap->SnapShot.POutDiag.Q;
	    snapsht->IOutDiag.I     = mmap->SnapShot.IOutDiag.I;
	    snapsht->IOutDiag.Q     = mmap->SnapShot.IOutDiag.Q;
	    return OK;
	 }
      break;

      case LrfscDrvrSET_PIC:                          /* LrfscDrvrPicSetBuf PI Controller */
	 if (rcnt >= sizeof(LrfscDrvrPicSetBuf)) {
	    picbuff = (LrfscDrvrPicSetBuf *) arg;
	    mcon->Pic.KI = picbuff->KI;
	    mcon->Pic.KP = picbuff->KP;
	    mmap->Pic.KI = (short) mcon->Pic.KI;
	    mmap->Pic.KP = (short) mcon->Pic.KP;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_PIC:
	 if (wcnt >= sizeof(LrfscDrvrPicSetBuf)) {
	    picbuff = (LrfscDrvrPicSetBuf *) arg;
	    picbuff->KI = mcon->Pic.KI;
	    picbuff->KP = mcon->Pic.KP;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_PULSE_LENGTH:         /* ulong RF Pulse length */
	 if (lap) {
	    *lap = (unsigned short) mmap->RfOffTime;
	    return OK;
	 }
      break;

      case LrfscDrvrSET_MAX_PULSE_LENGTH: /* ulong maximum RF pulse length */
	 if (lap) {
	    mcon->RfOnMaxLen = lav;
	    mmap->RfOnMaxLen = (unsigned short) mcon->RfOnMaxLen;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_MAX_PULSE_LENGTH: /* ulong maximum RF pulse length */
	 if (lap) {
	    *lap = (unsigned long) mcon->RfOnMaxLen;
	    return OK;
	 }
      break;

      case LrfscDrvrSET_NEXT_CYCLE:           /* ulong Next cycle 1..32 */
	 if (lap) {
	    mmap->NextCycle = (unsigned short) lav;
	    return OK;
	 }
      break;

      case LrfscDrvrGET_PRES_CYCLE:
	 if (lap) {
	    sav = mmap->PresCycle;
	    *lap = sav;
	    return OK;
	 }
      break;

      case LrfscDrvrSET_CYCLE_CONFIG:                         /* LrfscDrvrConfigBuf Set a cycle configuration */
	 if (rcnt >= sizeof(LrfscDrvrConfigBuf)) {
	    confbuf = (LrfscDrvrConfigBuf *) arg;
	    err = IQValToInc(mcon, confbuf);
	    if (err != OK) return err;
	    err = SetConfiguration(mcon, confbuf->Which, confbuf->Cycle);
	    return err;
	 }
      break;

      case LrfscDrvrGET_CYCLE_CONFIG:                         /* LrfscDrvrConfigBuf Get a cycle configuration */
	 if (rcnt >= sizeof(LrfscDrvrConfigBuf)) {
	    confbuf = (LrfscDrvrConfigBuf *) arg;
	    return IncToIQVal(mcon, confbuf);
	    return OK;
	 }
      break;

      case LrfscDrvrSET_SKIP_COUNT:           /* ulong Set diagnostic skip count */
	 if (lap) {
	    mcon->SkipCount = lav;
	    return OK;
	 }
      break;

      case LrfscDrvrSET_SKIP_START:           /* ulong Set diagnostic skip count */
	 if (lap) {
	    *lap = mcon->SkipCount;
	    return OK;
	 }
      break;

      case LrfscDrvrSET_PULSE:                /* LrfscDrvrPulse Set acquisition pulses */
	 if (lap) {
	    if (lav <= LrfscDrvrPULSES) {
	       mcon->Pulse = lav;
	       return OK;
	    }
	 }
      break;

      case LrfscDrvrGET_DIAGNOSTICS:          /* LrfscDrvrDiagBuf Get a diagnostic ram */
	 if (wcnt >= sizeof(LrfscDrvrDiagBuf)) {
	    diagbuf = (LrfscDrvrDiagBuf *) arg;
	    diagbuf->SkipStart = mcon->SkipStart;
	    diagbuf->SkipCount = mcon->SkipCount;
	    cynum = diagbuf->Cycle;
	    sigch = diagbuf->Choice;
	    for (i=0; i<diagbuf->Size; i++) {
	       dst = &(diagbuf->Array[i]);
	       src = &(mcon->Diags[sigch][cynum][i]);
	       *dst = *src;
	    }
	    return OK;
	 }
      break;

      case  LrfscDrvrGET_VERSION:          /* LrfscDrvrVersion Get driver and VHDL versions */
	 if (wcnt >= sizeof(LrfscDrvrVersion)) {
	    verbuf = (LrfscDrvrVersion *) arg;
	    sav = mmap->VhdlVerH;
	    verbuf->Firmware = sav << 16;
	    sav = mmap->VhdlVerL;
	    verbuf->Firmware |= sav;
	    verbuf->Driver = COMPILE_TIME;
	    return OK;
	 }
      break;

      default:
      break;
   }

   /***********************************/
   /* End of switch                   */
   /***********************************/

   pseterr(EINVAL);       /* Invalid argument */
   return(SYSERR);
}

/***************************************************************************/
/* READ                                                                    */
/***************************************************************************/

int LrfscDrvrRead(wa, flp, u_buf, cnt)
LrfscDrvrWorkingArea *wa;
struct file *flp;
char *u_buf;
int cnt; {

LrfscDrvrClientContext *ccon;    /* Client context */
LrfscDrvrClientQueue   *queue;
LrfscDrvrConnection    *rb;
int                    cnum;    /* Client number */
int                    wcnt;    /* Writable byte counts at arg address */
int                    ps;
unsigned int           iq;

   if (u_buf != NULL) {
      wcnt = wbounds((int)u_buf);           /* Number of writable bytes without error */
      if (wcnt < sizeof(LrfscDrvrConnection)) {
	 pseterr(EINVAL);
	 cprintf("LrfscDrvr READ: First Exit\n");
	 return 0;
      }
   }

   cnum = minor(flp->dev) -1;
   ccon = &(wa->ClientContexts[cnum]);

   queue = &(ccon->Queue);
   if (queue->QOff) {
      disable(ps);
      {
	 queue->Size   = 0;
	 queue->Tail   = 0;
	 queue->Head   = 0;
	 queue->Missed = 0;         /* ToDo: What to do with this info ? */
	 sreset(&(ccon->Semaphore));
      }
      restore(ps);
   }

   if (swait(&(ccon->Semaphore), SEM_SIGABORT)) {

      /* EINTR = "Interrupted system call" */

      pseterr(EINTR);   /* We have been signaled */
      return 0;
   }

   rb = (LrfscDrvrConnection *) u_buf;

   if (queue->Size) {
      disable(ps);
      {
	 iq = queue->Tail;
	 *rb = queue->Queue[iq++];
	 if (iq < LrfscDrvrCLIENT_QUEUE_SIZE) queue->Tail = iq;
	 else                                 queue->Tail = 0;
	 queue->Size--;
      }
      restore(ps);
      return sizeof(LrfscDrvrConnection);
   }

   pseterr(EINTR);
   return 0;
}

/***************************************************************************/
/* WRITE                                                                   */
/***************************************************************************/

int LrfscDrvrWrite(wa, flp, u_buf, cnt)
LrfscDrvrWorkingArea * wa;       /* Working area */
struct file * flp;              /* File pointer */
char * u_buf;                   /* Users buffer */
int cnt; {                      /* Byte count in buffer */

   pseterr(EPERM);              /* Not supported */
   return 0;
}

/***************************************************************************/
/* SELECT                                                                  */
/***************************************************************************/

int LrfscDrvrSelect(wa, flp, wch, ffs)
LrfscDrvrWorkingArea * wa;      /* Working area */
struct file * flp;              /* File pointer */
int wch;                        /* Read/Write direction */
struct sel * ffs; {             /* Selection structurs */

LrfscDrvrClientContext * ccon;
int cnum;

   cnum = minor(flp->dev) -1;
   ccon = &(wa->ClientContexts[cnum]);

   if (wch == SREAD) {
      ffs->iosem = (int *) &(ccon->Semaphore); /* Watch out here I hope   */
      return OK;                               /* the system dosn't swait */
   }                                           /* the read does it too !! */

   pseterr(EACCES);         /* Permission denied */
   return SYSERR;
}

/*************************************************************/
/* Dynamic loading information for driver install routine.   */
/*************************************************************/

struct dldd entry_points = {
   LrfscDrvrOpen,
   LrfscDrvrClose,
   LrfscDrvrRead,
   LrfscDrvrWrite,
   LrfscDrvrSelect,
   LrfscDrvrIoctl,
   LrfscDrvrInstall,
   LrfscDrvrUninstall,
};
@


1.18
log
@*** empty log message ***
@
text
@d176 1
d200 1
a200 1
   vec = &(*va[0]);
d205 1
d212 1
a212 1
      vec = &(*va[i]);
d222 1
d233 2
a234 1
      vec            = &(*va[i]);
d237 1
a237 1
      vec->Ticks     = 0;
d240 3
a242 2
   vec = &(*va[i]);
   vec->Ticks = 0xFFFF;                        /* Saftey net, continue forever */
d280 2
a281 2
volatile LrfscDrvrVectorArray   *dst;
LrfscDrvrVectorArray            *src;         /* Vector array */
d297 1
a297 1
      src = &((*mcon).Vectors[(int) cnf][(int) cyc]);
d299 1
a299 1
      dst = (volatile LrfscDrvrVectorArray *)
d304 8
a311 6
	 dst[i]->Ticks             = src[i]->Ticks;
	 dst[i]->IncI.Shorts.High  = src[i]->IncI.Shorts.High;
	 dst[i]->IncI.Shorts.Low   = src[i]->IncI.Shorts.Low;
	 dst[i]->IncQ.Shorts.High  = src[i]->IncQ.Shorts.High;
	 dst[i]->IncQ.Shorts.Low   = src[i]->IncQ.Shorts.Low;
	 if (src[i]->Ticks == 0) break;
d539 1
a539 1
   mcon->SignalChoices[0]        = LrfscDrvrDiagREFLECTED;
d541 1
a541 1
   mcon->SignalChoices[2]        = LrfscDrvrDiagCAVITY;
d557 1
d559 2
a560 1
      vec             = &(*va[0]);
d564 3
a566 5
      vec             = &(*va[1]);
      vec->Ticks      = 0xFFFF;
      vec->IncI.Long  = 0;
      vec->IncQ.Long  = 0;
      vec             = &(*va[2]);
d570 1
d572 2
a573 5
      vec             = &(*va[0]);
      vec->Ticks      = 0xFFFF;
      vec->IncI.Long  = 0;
      vec->IncQ.Long  = 0;
      vec             = &(*va[1]);
d697 1
a697 1
		  src = ram[i];
@


1.17
log
@*** empty log message ***
@
text
@d298 1
a298 1
      for (i=0; i< LrfscDrvrCONFIG_POINTS; i++) {
@


1.16
log
@*** empty log message ***
@
text
@d553 1
a553 1
      vec->IncI.Long  = 4000;
d559 4
d568 4
@


1.15
log
@*** empty log message ***
@
text
@d712 13
@


1.14
log
@*** empty log message ***
@
text
@d174 4
a177 2
LrfscDrvrConfigArray *dst;     /* Configuration array */
LrfscDrvrConfigPoint pi, *p1, *p2;
a178 1
signed short t;
d181 2
d191 16
a206 2
   dst = &((*mcon).Configs[(int) buf->Which][(int) buf->Cycle]); /* Set all entries 0,0,0 */
   bzero((void *) dst, sizeof(LrfscDrvrConfigArray));
a207 2
   p2 = &(buf->Array[0]);
   pi = *p2;
d209 3
d215 8
a222 5
      t = p2->Ticks - p1->Ticks;
      if (t > 0) {
	 dst[i]->Ticks = t;
	 dst[i]->IQ.I  = (p2->IQ.I - p1->IQ.I)/t;
	 dst[i]->IQ.Q  = (p2->IQ.Q - p1->IQ.Q)/t;
d230 4
a233 2
      dst[i]->IQ.I = pi.IQ.I - p2->IQ.I;
      dst[i]->IQ.Q = pi.IQ.Q - p2->IQ.Q;
d236 4
a239 1
   dst[i]->Ticks = 0xFFFF;                        /* Saftey net, continue forever */
d251 1
a251 6
LrfscDrvrConfigArray *src;
LrfscDrvrConfigArray *dst;

int i, j;
signed short iv, qv;
unsigned short   tv;
d261 3
a263 25
   src = &((*mcon).Configs[(int) buf->Which][(int) buf->Cycle]); /* Set all entries 0,0,0 */
   dst = &(buf->Array);
   bzero((void *) dst, sizeof(LrfscDrvrConfigArray));

   iv = 0; qv = 0; tv = 0;
   buf->Flag = LrfscDrvrFunctionSTOP;

   for (i=0; i<buf->Points; i++) {
      if (i >= LrfscDrvrCONFIG_POINTS) break;
      if (src[i]->Ticks) {
	 for (j=0; j<src[i]->Ticks; j++) {
	    iv += src[i]->IQ.I;
	    qv += src[i]->IQ.Q;
	    tv++;
	 }
	 dst[i]->Ticks = tv;
	 dst[i]->IQ.I  = iv;
	 dst[i]->IQ.Q  = qv;
      } else {
	 if ((src[i]->IQ.I == 0) && (src[i]->IQ.Q)) {
	    buf->Flag = LrfscDrvrFunctionREPEAT;
	    return OK;
	 }
      }
   }
d275 16
a290 2
volatile LrfscDrvrConfigArray   *dst;
LrfscDrvrConfigArray            *src;
d292 1
a292 1
int i;
d294 13
a306 16
   moad = &(mcon->Address);
   mmap  = (LrfscDrvrMemoryMap *) moad->VMEAddress;
   mmap->RamSelect = cnf;
   EIEIO;
   SYNC;

   src = &((*mcon).Configs[(int) cnf][(int) cyc]);
   dst = (volatile LrfscDrvrConfigArray *)
	 ( (unsigned long) moad->RamAddress
       |   (unsigned long) ((cyc & 31) << 14) );

   for (i=0; i< LrfscDrvrCONFIG_POINTS; i++) {
      dst[i]->Ticks = src[i]->Ticks;
      dst[i]->IQ.I  = src[i]->IQ.I;
      dst[i]->IQ.Q  = src[i]->IQ.Q;
      if (src[i]->Ticks) break;
d308 1
d354 1
a354 1
int                                                     i,j;
d360 1
a360 1
      mmap->State = LrfscDrvrStateCONFIG;
d367 1
a367 1
	 mmap->RamSelect = i;
d371 13
a383 13
      mmap->Control            = mcon->Control;
      mmap->Vector             = moad->InterruptVector;
      mmap->RamSelect          = mcon->RamSelect;
      mmap->ResCtrl.Time       = mcon->ResCtrl.Time;
      mmap->ResCtrl.Value      = mcon->ResCtrl.Value;
      mmap->SwitchCtrl         = mcon->SwitchCtrl;
      mmap->SoftSwitch         = mcon->SoftSwitch;
      mmap->SnapShot.DiagTime  = mcon->DiagTime;
      mmap->Pic.KP             = mcon->Pic.KP;
      mmap->Pic.KI             = mcon->Pic.KI;
      mmap->NextCycle          = 0;
      mmap->RfOnMaxLen         = mcon->RfOnMaxLen;
      mmap->State              = mcon->State;
d408 7
a414 4
volatile LrfscDrvrModuleAddress *moad;        /* Module address, vector, level, ssch */
volatile LrfscDrvrMemoryMap     *mmap;        /* Module Memory map */
unsigned long                   addr;         /* VME base address */
unsigned long                   coco;         /* Completion code */
d473 2
a474 2
   mmap->State = 0;            /* Interrupts off */
   wrd   = mmap->IrqSource;    /* Clear interrup register */
d550 14
a563 7
      mcon->Configs[LrfscDrvrConfigSETPOINTS][cy][0].Ticks = 0xFFFF;
      mcon->Configs[LrfscDrvrConfigSETPOINTS][cy][0].IQ.I  = 4000;
      mcon->Configs[LrfscDrvrConfigSETPOINTS][cy][0].IQ.Q  = 0;

      mcon->Configs[LrfscDrvrConfigFEEDFORWARD][cy][0].Ticks = 0xFFFF;
      mcon->Configs[LrfscDrvrConfigFEEDFORWARD][cy][0].IQ.I  = 0;
      mcon->Configs[LrfscDrvrConfigFEEDFORWARD][cy][0].IQ.Q  = 0;
d676 1
a676 1
	    sigc = (LrfscDrvrDiagSignalChoice) mmap->SignalChoices[si];
d681 1
a681 1
	       mmap->RamSelect = (LrfscDrvrRamSelection) si + LrfscDrvrRamDIAG1;
d1282 1
a1282 1
	    *lap = mmap->RfOffTime;
@


1.13
log
@*** empty log message ***
@
text
@d175 1
a175 1
LrfscDrvrConfigPoint *p1, *p2;
d192 1
d208 5
a212 1
   if (buf->Flag == LrfscDrvrFunctionREPEAT) i++; /* 0,0,0 is the repeat code */
a275 1
volatile signed short *ram;
d279 1
a279 1
int ofs, i;
a286 2
   ram = (volatile signed short *) moad->RamAddress;

d288 3
a290 2
   ofs = cyc * LrfscDrvrBUF_IQ_ENTRIES;
   dst = (volatile LrfscDrvrConfigArray *) &(ram[ofs]);
d296 1
a655 1
	    mmap->RamSelect = (LrfscDrvrRamSelection) si + LrfscDrvrRamDIAG1;
d659 2
a660 1
	    if (mcon->Pulse == pnum) {
d664 2
a665 1
		  *dst = *src;
@


1.12
log
@*** empty log message ***
@
text
@d168 96
d271 3
a273 3
LrfcsDrvrRamIqArray     *ram;
LrfscDrvrBufIqArray     *buf;
LrfscDrvrIQPair         *src, *dst;
d283 3
a285 2
   ram = (LrfcsDrvrRamIqArray *) moad->RamAddress;
   buf = &(mcon->Configs[(int) cnf][cyc]);
d287 1
d289 4
a292 7
   for (i=0; i<LrfscDrvrBUF_IQ_ENTRIES; i++) {

      src = buf[i];
      dst = ram[ofs + i];

      dst->I = src->I;
      dst->Q = src->Q;
d349 2
d353 1
a353 5
	 for (j=0; j<LrfscDrvrCYCLES; j++) {
	    if (mcon->ValidConfigs[i][j]) {
	       SetConfiguration(mcon, (LrfscDrvrConfig) i, j);
	    }
	 }
a354 4
      for (i=0; i<LrfscDrvrDiagSIGNAL_CHOICES; i++)
	      SetSignalChoice(mcon, i);
      for (i=0; i<LrfscDrvrMatrixMATRICES; i++)
	      SetMatrixCoefficient(mcon, (LrfscDrvrMatrix) i);
d403 1
d408 1
a408 1
   cprintf("IrqSource    %03d 0x%08X \n",(int) &(pmap->IrqSource   ),  (int) &(pmap->IrqSource   ));
d410 8
a417 8
   cprintf("ResCtrl      %03d 0x%08X \n",(int) &(pmap->ResCtrl     ),  (int) &(pmap->ResCtrl     ));
   cprintf("Matrix       %03d 0x%08X \n",(int) &(pmap->Matrix      ),  (int) &(pmap->Matrix      ));
   cprintf("SnapShot     %03d 0x%08X \n",(int) &(pmap->SnapShot    ),  (int) &(pmap->SnapShot    ));
   cprintf("Pic          %03d 0x%08X \n",(int) &(pmap->Pic         ),  (int) &(pmap->Pic         ));
   cprintf("RfOffTime    %03d 0x%08X \n",(int) &(pmap->RfOffTime   ),  (int) &(pmap->RfOffTime   ));
   cprintf("VhdlVerH     %03d 0x%08X \n",(int) &(pmap->VhdlVerH    ),  (int) &(pmap->VhdlVerH    ));
   cprintf("Status       %03d 0x%08X \n",(int) &(pmap->Status      ),  (int) &(pmap->Status      ));
   cprintf("RfOnMaxLen   %03d 0x%08X \n",(int) &(pmap->RfOnMaxLen  ),  (int) &(pmap->RfOnMaxLen  ));
d531 10
d868 1
a868 1
int i, j, cynum, size;
d1294 4
a1297 5
	    for (i=confbuf->Start; i<confbuf->Start+confbuf->Items; i++ ) {
	       mcon->Configs[confbuf->Which][confbuf->Cycle][i] = confbuf->Array[i];
	    }
	    mcon->ValidConfigs[confbuf->Which][confbuf->Cycle] = confbuf->Valid;
	    return SetConfiguration(mcon, confbuf->Which ,confbuf->Cycle);
d1302 1
a1302 1
	 if (wcnt >= sizeof(LrfscDrvrConfigBuf)) {
d1304 1
a1304 4
	    confbuf->Valid = mcon->ValidConfigs[confbuf->Which][confbuf->Cycle];
	    for (i=confbuf->Start; i<confbuf->Start+confbuf->Items; i++ ) {
	       confbuf->Array[i] = mcon->Configs[confbuf->Which][confbuf->Cycle][i];
	    }
@


1.11
log
@*** empty log message ***
@
text
@d420 1
a420 1
   mcon->DiagTime                = 0xFF;
d422 2
a423 2
   mcon->Pic.KI                  = 0;
   mcon->Pic.KP                  = 0;
d428 12
a439 6
   mcon->Coefficients[0].MatrixA = 0x7fff;
   mcon->Coefficients[0].MatrixC = 0x7fff;
   mcon->Coefficients[1].MatrixA = 0x7fff;
   mcon->Coefficients[1].MatrixC = 0x7fff;
   mcon->Coefficients[2].MatrixA = 0x7fff;
   mcon->Coefficients[2].MatrixC = 0x7fff;
d579 46
a624 46
	int								i, count;
	LrfscDrvrModuleContext			*mcon;	/* Module context */
	volatile LrfscDrvrModuleAddress	*moad;	/* Modules address */
	LrfscDrvrWorkingArea			*wa;

	/*Allocate the driver working area*/

	wa = (LrfscDrvrWorkingArea *) sysbrk(sizeof(LrfscDrvrWorkingArea));
	if (!wa) {
		cprintf("LrfscDrvrInstall: NOT ENOUGH MEMORY(WorkingArea)\n");
		pseterr(ENOMEM);          /* Not enough core */
		return((char *) SYSERR);
	}
	Wa = wa;                     /* Global working area pointer */

	/****************************************/
	/* Initialize the driver's working area */
	/* and add the modules ISR into LynxOS  */
	/****************************************/

	bzero((void *) wa, sizeof(LrfscDrvrWorkingArea));	/* Clear working area */

	count = 0;
	for (i=0; i<info->Modules; i++) {
		mcon	= &(wa->ModuleContexts[i]);
		moad	= &(mcon->Address);
		*moad	= info->Addresses[i];

		if (AddModule(mcon,count) != OK) {
			cprintf("LrfscDrvr: Module: %d Not Installed\n", i+1);
			bzero((void *) moad,sizeof(LrfscDrvrModuleAddress));     /* Wipe it out */
		} else {
			count++;
			mcon->ModuleIndex = count -1;
			cprintf("LrfscDrvr: Module %d. VME Addr: %x RAM Addr: %x Vect: %x Level: %x Installed OK\n",
					count,
					moad->VMEAddress,
					moad->RamAddress,
					moad->InterruptVector,
					moad->InterruptLevel);
		}

	}
	wa->Modules = count;
	cprintf("LrfscDrvr: Installed: %d LRFSC Modules in Total\n",count);
	return((char*) wa);
d634 1
a634 1
	cprintf("LrfscDrvr: ERROR: UnInstall capabilities are not supported\n");
d636 1
a636 1
	/* EPERM = "Operation not permitted" */
d638 2
a639 2
	pseterr(EPERM);             /* Not supported */
	return SYSERR;
d652 2
a653 2
	int cnum;                          /* Client number */
	LrfscDrvrClientContext * ccon;    /* Client context */
d655 2
a656 2
	/* We allow one client per minor device, we use the minor device */
	/* number as an index into the client contexts array. */
d658 2
a659 2
	cnum = minor(flp->dev) -1;
	if ((cnum < 0) || (cnum >= LrfscDrvrCLIENT_CONTEXTS)) {
d661 1
a661 1
		/* EFAULT = "Bad address" */
d663 4
a666 4
		pseterr(EFAULT);
		return SYSERR;
	}
	ccon = &(wa->ClientContexts[cnum]);
d669 1
a669 1
	/* If already open by someone else, give a permission denied error */
d671 1
a671 1
	if (ccon->InUse) {
d673 2
a674 2
		/* This next error is normal */
		/* EBUSY = "Resource busy" */
d676 3
a678 3
		pseterr(EBUSY);           /* File descriptor already open */
		return SYSERR;
	}
d680 1
a680 1
	/* Initialize a client context */
d682 6
a687 6
	bzero((void *) ccon,(long) sizeof(LrfscDrvrClientContext));
	ccon->ClientIndex = cnum;
	ccon->Timeout     = LrfscDrvrDEFAULT_TIMEOUT;
	ccon->InUse       = 1;
	ccon->Pid         = getpid();
	return OK;
d698 1
a698 1
	int cnum;                          /* Client number */
d700 2
a701 2
	LrfscDrvrModuleContext     * mcon;   /* Module context */
	LrfscDrvrClientContext     * ccon;   /* Client context */
d703 2
a704 2
	/* We allow one client per minor device, we use the minor device */
	/* number as an index into the client contexts array.            */
d706 2
a707 2
	cnum = minor(flp->dev) -1;
	if ((cnum < 0) || (cnum >= LrfscDrvrCLIENT_CONTEXTS)) {
d709 1
a709 1
		/* EFAULT = "Bad address" */
d711 7
a717 4
		pseterr(EFAULT);
		return SYSERR;
	}
	ccon = &(Wa->ClientContexts[cnum]);
d719 2
a720 5
	/* Cancel any pending timeouts */
	/* Disconnect this client from events */
	
	CancelTimeout(&ccon->Timer);
	mcon->Clients[ccon->ClientIndex] = 0;
d722 1
a722 1
	/* Wipe out the client context */
d724 2
a725 2
	bzero((void *) ccon,sizeof(LrfscDrvrClientContext));
	return(OK);
d738 165
a902 539
	int cnum;               		/* Client number */
	int rcnt, wcnt;         		/* Readable, Writable byte counts at arg address */
	long lav;						/* Long value from arg */
	volatile long *lap;         	/* Long Value pointed to by Arg */
	volatile unsigned short *sap;	/* Short IO value pointer */
	unsigned short sav;				/* Short IO value */
	
	volatile LrfscDrvrMemoryMap	*mmap;
	
	LrfscDrvrClientContext		*ccon;
	LrfscDrvrModuleContext		*mcon;	
	LrfscDrvrRawIoBlock             *riob;
	LrfscDrvrConnection             *conx;
	LrfscDrvrDiagChoices		*diagch;
	LrfscDrvrDiagSignalChoice	sigch;
	LrfscDrvrResCtrl                *resctl;
	LrfscDrvrAnalogSwitch 		*anlgsw;
	LrfscDrvrSoftSwitch             *softsw;
	LrfscDrvrMatrixCoefficientsBuf  *coefbuf;
	LrfscDrvrMatrix                 matrx;
	LrfscDrvrDiagSnapShot		*snapsht;
	LrfscDrvrPicSetBuf              *picbuff;
	LrfscDrvrConfigBuf              *confbuf;
	LrfscDrvrDiagBuf                *diagbuf;
	LrfscDrvrVersion                *verbuf;
	LrfscDrvrModuleAddress          *moadbuf;
	LrfscDrvrClientList             *clsbuf;
	LrfscDrvrClientConnections	*ccnbuf;
	LrfscDrvrIQPair                 *src, *dst;
	
	int i, j, cynum, plnum, size;

	/* Check argument contains a valid address for reading or writing. */
	/* We can not allow bus errors to occur inside the driver due to   */
	/* the caller providing a garbage address in "arg". So if arg is   */
	/* not null set "rcnt" and "wcnt" to contain the byte counts which */
	/* can be read or written to without error. */

	if (arg != NULL) {
		rcnt = rbounds((int)arg);       /* Number of readable bytes without error */
		wcnt = wbounds((int)arg);       /* Number of writable bytes without error */
		if (rcnt < sizeof(long)) {      /* We at least need to read one long */
			cprintf("LrfscDrvrIoctl: ILLEGAL NON NULL ARG POINTER, RCNT=%d/%d\n",
					rcnt,sizeof(long));
			pseterr(EINVAL);        /* Invalid argument */
			return SYSERR;
		}
		lav = *((long *) arg);       /* Long argument value */
		lap =   (long *) arg ;       /* Long argument pointer */
	} else {
		rcnt = 0; wcnt = 0; lav = 0; lap = NULL; /* Null arg = zero read/write counts */
	}

	/* We allow one client per minor device, we use the minor device */
	/* number as an index into the client contexts array. */

	cnum = minor(flp->dev) -1;
	if ((cnum < 0) || (cnum >= LrfscDrvrCLIENT_CONTEXTS)) {
		pseterr(ENODEV);          /* No such device */
		return SYSERR;
	}

	/* We can't control a file which is not open. */

	ccon = &(wa->ClientContexts[cnum]);
	if (ccon->InUse == 0) {
		cprintf("LrfscDrvrIoctl: DEVICE %2d IS NOT OPEN\n",cnum+1);
		pseterr(EBADF);           /* Bad file number */
		return SYSERR;
	}

	mcon = &(wa->ModuleContexts[ccon->ModuleIndex]); /* Default module selected */
	mmap =  (LrfscDrvrMemoryMap	*) mcon->Address.VMEAddress;

	/*************************************/
	/* Decode callers command and do it. */
	/*************************************/

	switch (cm) {

	case LrfscDrvrSET_MODULE:              /* Select the module to work with */
		if ((lav >= 1) &&  (lav <= Wa->Modules)) {
			ccon->ModuleIndex = lav -1;
			return OK;
		}
		break;

	case LrfscDrvrGET_MODULE:
		if (lap) {
			*lap = ccon->ModuleIndex +1;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_MODULE_COUNT:
		if (lap) {
			*lap = Wa->Modules;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_MODULE_ADDRESS:	/* LrfscDrvrModuleAddress Read */
		if (wcnt >= sizeof(LrfscDrvrModuleAddress)) {
			moadbuf = (LrfscDrvrModuleAddress *) arg;
			*moadbuf = mcon->Address;
			return OK;
		}
		break;

	case LrfscDrvrRESET:
		return Reset(mcon);
		
	case LrfscDrvrGET_STATUS:		/* LrfscDrvrStatus Get status */
		if (lap) {
			sav = mmap->Status;
			*lap = (unsigned long) sav;
			return OK;
		}
		break;
		
	case LrfscDrvrSET_SW_DEBUG:		/* ulong Set software debug level */
		if (lap) {
			ccon->Debug = lav;
			if (lav)	cprintf("lrfsc driver:Debug level:%d on\n", (int) lav);
			else		cprintf("lrfsc driver:Debug off\n");
			return OK;
		}
		break;
		
	case LrfscDrvrGET_SW_DEBUG:		/* ulong Get software debug level */
		if (lap) {
			*lap = ccon->Debug;
			return OK;
		}
		break;
		
	case LrfscDrvrRAW_READ:		/* LrfscDrvrRawIoBlock Read  */
		if (rcnt >= sizeof(LrfscDrvrRawIoBlock)) {
			riob = (LrfscDrvrRawIoBlock *) arg;
			RawIo(mcon, riob, READ_FLAG);
			return OK;
		}
		break;
		
	case LrfscDrvrRAW_WRITE:	/* LrfscDrvrRawIoBlock Write */
		if (rcnt >= sizeof(LrfscDrvrRawIoBlock)) {
			riob = (LrfscDrvrRawIoBlock *) arg;
			RawIo(mcon, riob, WRITE_FLAG);
			return OK;
		}
		break;
		
	case LrfscDrvrSET_TIMEOUT:		/* ulong Set read timeout */
		if (lap) {
			ccon->Timeout = lav;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_TIMEOUT:		/* ulong Get read timeout */
		if (lap) {
			*lap = ccon->Timeout;
			return OK;
		}
		break;
		
	case LrfscDrvrCONNECT:
		if (rcnt >= sizeof(LrfscDrvrConnection)) { 
			conx = (LrfscDrvrConnection *) arg;
			if (conx->Interrupt) return Connect(conx, ccon);
		}
		break;
		
	case LrfscDrvrDISCONNECT:
		if (rcnt >= sizeof(LrfscDrvrConnection)) { 
			conx = (LrfscDrvrConnection *) arg; 
			if (conx->Interrupt == 0) conx->Interrupt = LrfscDrvrINTERUPT_MASK;
			return DisConnect(conx, ccon);
		}
		break;
		
	case LrfscDrvrSET_QUEUE_FLAG:		/* ulong Set queue off 1 or on 0 */
		if (lap) {
			ccon->Queue.QOff = lav;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_QUEUE_FLAG:
		if (lap) {
			*lap = ccon->Queue.QOff;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_QUEUE_SIZE:
		if (lap) {
			*lap = ccon->Queue.Size;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_QUEUE_OVERFLOW:
		if (lap) {
			*lap = ccon->Queue.Missed;
			ccon->Queue.Missed = 0;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_CLIENT_LIST:			/* LrfscDrvrClientList Get all clients */
		if (wcnt >= sizeof(LrfscDrvrClientList)) {
			clsbuf = (LrfscDrvrClientList *) arg;
			bzero((void *) clsbuf, sizeof(LrfscDrvrClientList));
			for (i=0; i<LrfscDrvrCLIENT_CONTEXTS; i++) {
				ccon = &(wa->ClientContexts[i]);
				if (ccon->InUse)
					clsbuf->Pid[clsbuf->Size++] = ccon->Pid;
			}
			return OK;
		}
		break;
		
	case LrfscDrvrGET_CLIENT_CONNECTIONS:	/* LrfscDrvrClientConnections Get clients connections */
		if (wcnt >= sizeof(LrfscDrvrClientConnections)) {
			ccnbuf = (LrfscDrvrClientConnections *) arg;
			ccnbuf->Size = 0; size = 0;
			for (i=0; i<LrfscDrvrCLIENT_CONTEXTS; i++) {
				ccon = &(wa->ClientContexts[i]);
				if ((ccon->InUse) && (ccon->Pid == ccnbuf->Pid)) {
					for (j=0; j<Wa->Modules; j++) {
						mcon = &(Wa->ModuleContexts[j]);
						if (mcon->Clients[i]) {
							ccnbuf->Connections[size].Module	= j+1;
							ccnbuf->Connections[size].Interrupt	= mcon->Clients[i];
							ccnbuf->Connections[size].Pulses	= ccon->Pulses;
							ccnbuf->Size = ++size;
						}
					}
				}
			}
			return OK;
		}
		break;

	case LrfscDrvrSET_STATE:			/* LrfscDrvrState Get Module state */
		if (lap) {
			sap = &(mmap->State);
			sav = (unsigned short) *lap;
			if (sav < LrfscDrvrSTATES) {
				*sap = sav;
				mcon->State = (LrfscDrvrState) sav;
				return OK;
			}
		}
		break;
		
	case LrfscDrvrGET_STATE:
		if (lap) {
			sap = &(mmap->State);
			sav = *sap;
			if (sav >= LrfscDrvrSTATES) {
				*sap = (unsigned short ) LrfscDrvrStateCONFIG;
				mcon->State = LrfscDrvrStateCONFIG;
			}
			*lap = (unsigned long) sav;
			return OK;
		}
		break;

	case LrfscDrvrSET_DIAG_CHOICE:		/* Configure diagnostics channels */
		if (rcnt >= sizeof(LrfscDrvrDiagChoices)) { 
			diagch = (LrfscDrvrDiagChoices *) arg;
			for (i=0; i<LrfscDrvrDiagSIGNAL_CHOICES; i++) {
				sigch = *diagch[i];
				mcon->SignalChoices[i] = sigch;
				SetSignalChoice(mcon,i);
			}
			return OK;
		}
		break;
		
	case LrfscDrvrGET_DIAG_CHOICE:
		if (wcnt >= sizeof(LrfscDrvrDiagChoices)) {
			diagch = (LrfscDrvrDiagChoices *) arg;
			for (i=0; i<LrfscDrvrDiagSIGNAL_CHOICES; i++) {
				sigch = mcon->SignalChoices[i];
				*diagch[i] = sigch;
			}
			return OK;
		}
		break;

	case LrfscDrvrSET_RES_CTRL:			/* LrfscDrvrResCtrl Set Resonance control value */
		if (rcnt >= sizeof(LrfscDrvrResCtrl)) {
			resctl = (LrfscDrvrResCtrl *) arg;
			mcon->ResCtrl = *resctl;
			mmap->ResCtrl.Time	= (unsigned short) mcon->ResCtrl.Time;
			mmap->ResCtrl.Value	= (unsigned short) mcon->ResCtrl.Value;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_RES_CTRL:
		if (wcnt >= sizeof(LrfscDrvrResCtrl)) {
			resctl = (LrfscDrvrResCtrl *) arg;
			*resctl = mcon->ResCtrl;
			resctl->Cav.I = (unsigned short) mmap->ResCtrl.Cav.I;
			resctl->Cav.Q = (unsigned short) mmap->ResCtrl.Cav.Q;
			resctl->Fwd.I = (unsigned short) mmap->ResCtrl.Fwd.I;
			resctl->Fwd.Q = (unsigned short) mmap->ResCtrl.Fwd.Q;
			return OK;
		}
		break;

	case LrfscDrvrSET_ANALOGUE_SWITCH:	/* LrfscDrvrAnalogSwitch */
		if (rcnt >= sizeof(LrfscDrvrAnalogSwitch)) {
			anlgsw = (LrfscDrvrAnalogSwitch *) arg;
			mcon->SwitchCtrl = *anlgsw;
			mmap->SwitchCtrl = (unsigned short) mcon->SwitchCtrl;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_ANALOGUE_SWITCH:
		if (wcnt >= sizeof(LrfscDrvrAnalogSwitch)) {
			anlgsw = (LrfscDrvrAnalogSwitch *) arg;
			*anlgsw = mcon->SwitchCtrl;
			return OK;
		}
		break;

	case LrfscDrvrSET_SOFT_SWITCH:		/* LrfscDrvrSoftSwitch */
		if (rcnt >= sizeof(LrfscDrvrSoftSwitch)) {
			softsw = (LrfscDrvrSoftSwitch *) arg;
			mcon->SoftSwitch = *softsw;
			mmap->SoftSwitch = (unsigned short) mcon->SoftSwitch;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_SOFT_SWITCH:
		if (wcnt >= sizeof(LrfscDrvrSoftSwitch)) {
			softsw = (LrfscDrvrSoftSwitch *) arg;
			*softsw = mcon->SoftSwitch;
			return OK;
		}
		break;

	case LrfscDrvrSET_COEFFICIENTS:		/* LrfscDrvrMatrixCoefficientsBuf */
		if (rcnt >= sizeof(LrfscDrvrMatrixCoefficientsBuf)) {
			coefbuf = (LrfscDrvrMatrixCoefficientsBuf *) arg;
			matrx = coefbuf->Matrix;
			mcon->Coefficients[matrx] = coefbuf->Coeficients;
			return SetMatrixCoefficient(mcon, matrx);
		}
		break;
		
	case LrfscDrvrGET_COEFFICIENTS:
		if (wcnt >= sizeof(LrfscDrvrMatrixCoefficientsBuf)) {
			coefbuf = (LrfscDrvrMatrixCoefficientsBuf *) arg;
			matrx = coefbuf->Matrix;
			coefbuf->Coeficients = mcon->Coefficients[matrx];
			return OK;
		}
		break;

	case LrfscDrvrSET_SNAP_SHOT_TIME:	/* ulong Snapshot time */
		if (lap) {
			mcon->DiagTime = lav;
			mmap->SnapShot.DiagTime = (unsigned short) mcon->DiagTime;
			return OK;
		}
		
	case LrfscDrvrGET_SNAP_SHOTS:		/* LrfscDrvrDiagSnapShot */
		if (wcnt >= sizeof(LrfscDrvrDiagSnapShot)) {
			snapsht = (LrfscDrvrDiagSnapShot *) arg;
			snapsht->DiagTime	= mmap->SnapShot.DiagTime;
			snapsht->RefDiag.I	= mmap->SnapShot.RefDiag.I;
			snapsht->RefDiag.Q	= mmap->SnapShot.RefDiag.Q;
			snapsht->FwdDiag.I	= mmap->SnapShot.FwdDiag.I;
			snapsht->FwdDiag.Q	= mmap->SnapShot.FwdDiag.Q;
			snapsht->CavDiag.I	= mmap->SnapShot.CavDiag.I;
			snapsht->CavDiag.Q	= mmap->SnapShot.CavDiag.Q;
			snapsht->ErrDiag.I	= mmap->SnapShot.ErrDiag.I;
			snapsht->ErrDiag.Q	= mmap->SnapShot.ErrDiag.Q;
			snapsht->OutDiag.I	= mmap->SnapShot.OutDiag.I;
			snapsht->OutDiag.Q	= mmap->SnapShot.OutDiag.Q;
			snapsht->POutDiag.I	= mmap->SnapShot.POutDiag.I;
			snapsht->POutDiag.Q	= mmap->SnapShot.POutDiag.Q;
			snapsht->IOutDiag.I	= mmap->SnapShot.IOutDiag.I;
			snapsht->IOutDiag.Q	= mmap->SnapShot.IOutDiag.Q;
			return OK;			
		}
		break;

	case LrfscDrvrSET_PIC:				/* LrfscDrvrPicSetBuf PI Controller */
		if (rcnt >= sizeof(LrfscDrvrPicSetBuf)) {
			picbuff = (LrfscDrvrPicSetBuf *) arg;
			mcon->Pic.KI = picbuff->KI;
			mcon->Pic.KP = picbuff->KP;
			mmap->Pic.KI = (short) mcon->Pic.KI;
			mmap->Pic.KP = (short) mcon->Pic.KP;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_PIC:
		if (wcnt >= sizeof(LrfscDrvrPicSetBuf)) {
			picbuff = (LrfscDrvrPicSetBuf *) arg;
			picbuff->KI = mcon->Pic.KI;
			picbuff->KP = mcon->Pic.KP;
			return OK;
		}
		break;

	case LrfscDrvrGET_PULSE_LENGTH:		/* ulong RF Pulse length */
		if (lap) {
			*lap = mmap->RfOffTime;
			return OK;
		}
		break;
		
	case LrfscDrvrSET_MAX_PULSE_LENGTH: /* ulong maximum RF pulse length */
		if (lap) {
			mcon->RfOnMaxLen = lav;
			mmap->RfOnMaxLen = (unsigned short) mcon->RfOnMaxLen;
			return OK;
		}
		break;
		   
	case LrfscDrvrGET_MAX_PULSE_LENGTH: /* ulong maximum RF pulse length */
		if (lap) {
			*lap = (unsigned long) mcon->RfOnMaxLen;
			return OK;
		}
		break;
		   
	case LrfscDrvrSET_NEXT_CYCLE:		/* ulong Next cycle 1..32 */
		if (lap) {
			mmap->NextCycle = (unsigned short) lav;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_PRES_CYCLE:
		if (lap) {
			sav = mmap->PresCycle;
			*lap = sav;
			return OK;
		}
		break;

	case LrfscDrvrSET_CYCLE_CONFIG:				/* LrfscDrvrConfigBuf Set a cycle configuration */
		if (rcnt >= sizeof(LrfscDrvrConfigBuf)) {
			confbuf = (LrfscDrvrConfigBuf *) arg;
			for (i=confbuf->Start; i<confbuf->Start+confbuf->Items; i++ ) {
				mcon->Configs[confbuf->Which][confbuf->Cycle][i] = confbuf->Array[i];
			}
			mcon->ValidConfigs[confbuf->Which][confbuf->Cycle] = confbuf->Valid;
			return SetConfiguration(mcon, confbuf->Which ,confbuf->Cycle);			
		}
		break;
		
	case LrfscDrvrGET_CYCLE_CONFIG:				/* LrfscDrvrConfigBuf Get a cycle configuration */
		if (wcnt >= sizeof(LrfscDrvrConfigBuf)) {
			confbuf = (LrfscDrvrConfigBuf *) arg;
			confbuf->Valid = mcon->ValidConfigs[confbuf->Which][confbuf->Cycle];
			for (i=confbuf->Start; i<confbuf->Start+confbuf->Items; i++ ) {
				confbuf->Array[i] = mcon->Configs[confbuf->Which][confbuf->Cycle][i];
			}
			return OK;
		}
		break;

	case LrfscDrvrSET_SKIP_COUNT:		/* ulong Set diagnostic skip count */
		if (lap) {
			mcon->SkipCount = lav;
			return OK;
		}
		break;
		
	case LrfscDrvrSET_SKIP_START:		/* ulong Set diagnostic skip count */
		if (lap) {
			*lap = mcon->SkipCount;
			return OK;
		}
		break;
		
	case LrfscDrvrSET_PULSE_MASK:		/* LrfscDrvrPulse Set acquisition pulses */
		if (lap) {
			mcon->Pulses = lav;
			return OK;
		}
		break;
		
	case LrfscDrvrGET_DIAGNOSTICS:		/* LrfscDrvrDiagBuf Get a diagnostic ram */
		if (wcnt >= sizeof(LrfscDrvrDiagBuf)) {
			diagbuf = (LrfscDrvrDiagBuf *) arg;
			diagbuf->SkipStart = mcon->SkipStart;
			diagbuf->SkipCount = mcon->SkipCount;
			if (mcon->Pulses & diagbuf->Pulses) {
				for (plnum=0; plnum<LrfscDrvrPULSES; plnum++) {
					if ((1 << plnum) & diagbuf->Pulses) {
						cynum = diagbuf->Cycle;
						sigch = diagbuf->Choice;
						for (i=0; i<diagbuf->Size; i++) {
							dst = diagbuf->Array[i];
							src = &(mcon->Diags[sigch][cynum][plnum])[i];
							*dst = *src;
							*diagbuf->Array[i] = mcon->Diags[sigch][cynum][plnum][i];
						}
						return OK;
					}
				}
				
			}
		}
		break;

	case  LrfscDrvrGET_VERSION:          /* LrfscDrvrVersion Get driver and VHDL versions */
		if (wcnt >= sizeof(LrfscDrvrVersion)) {
			verbuf = (LrfscDrvrVersion *) arg;
			sav = mmap->VhdlVerH;
			verbuf->Firmware = sav << 16;
			sav = mmap->VhdlVerL;
			verbuf->Firmware |= sav;
			verbuf->Driver = COMPILE_TIME;
			return OK;			
 		}
		break;

	default:
		break;
	}

	/***********************************/
	/* End of switch                   */
	/***********************************/
d904 370
a1273 2
	pseterr(EINVAL);       /* Invalid argument */
	return(SYSERR);
d1286 32
a1317 55
	LrfscDrvrClientContext *ccon;    /* Client context */
	LrfscDrvrClientQueue   *queue;
	LrfscDrvrConnection    *rb;
	int                    cnum;    /* Client number */
	int                    wcnt;    /* Writable byte counts at arg address */
	int                    ps;
	unsigned int           iq;

	if (u_buf != NULL) {
		wcnt = wbounds((int)u_buf);           /* Number of writable bytes without error */
		if (wcnt < sizeof(LrfscDrvrConnection)) {
			pseterr(EINVAL);
			cprintf("LrfscDrvr READ: First Exit\n");
			return 0;
		}
	}

	cnum = minor(flp->dev) -1;
	ccon = &(wa->ClientContexts[cnum]);

	queue = &(ccon->Queue);
	if (queue->QOff) {
		disable(ps);
		{
			queue->Size   = 0;
			queue->Tail   = 0;
			queue->Head   = 0;
			queue->Missed = 0;         /* ToDo: What to do with this info ? */
			sreset(&(ccon->Semaphore));
		}
		restore(ps);
	}

	if (swait(&(ccon->Semaphore), SEM_SIGABORT)) {

		/* EINTR = "Interrupted system call" */

		pseterr(EINTR);   /* We have been signaled */
		return 0;
	}

	rb = (LrfscDrvrConnection *) u_buf;

	if (queue->Size) {
		disable(ps);
		{
			iq = queue->Tail;
			*rb = queue->Queue[iq++];
			if (iq < LrfscDrvrCLIENT_QUEUE_SIZE)	queue->Tail = iq;
			else									queue->Tail = 0;
			queue->Size--;
		}
		restore(ps);
		return sizeof(LrfscDrvrConnection);
	}
d1319 25
a1343 2
	pseterr(EINTR);
	return 0;
d1356 2
a1357 2
	pseterr(EPERM);              /* Not supported */
	return 0;
d1365 1
a1365 1
LrfscDrvrWorkingArea * wa;       /* Working area */
d1370 2
a1371 2
	LrfscDrvrClientContext * ccon;
	int cnum;
d1373 2
a1374 2
	cnum = minor(flp->dev) -1;
	ccon = &(wa->ClientContexts[cnum]);
d1376 4
a1379 4
	if (wch == SREAD) {
		ffs->iosem = (int *) &(ccon->Semaphore); /* Watch out here I hope   */
		return OK;                               /* the system dosn't swait */
	}                                           /* the read does it too !! */
d1381 2
a1382 2
	pseterr(EACCES);         /* Permission denied */
	return SYSERR;
d1390 8
a1397 8
		LrfscDrvrOpen,
		LrfscDrvrClose,
		LrfscDrvrRead,
		LrfscDrvrWrite,
		LrfscDrvrSelect,
		LrfscDrvrIoctl,
		LrfscDrvrInstall,
		LrfscDrvrUninstall,
@


1.10
log
@*** empty log message ***
@
text
@d494 6
a499 6
LrfscDrvrConnection                     rb;
unsigned int                            i,j,iq,ci,si,vd,skpstr,skpcnt;
unsigned short                          isrc, csrc, pnum, cnum, pmsk;
LrfscDrvrDiagSignalChoice       sigc;
LrfcsDrvrRamIqArray                     *ram;
LrfscDrvrIQPair                         *src, *dst;
d501 2
a502 2
   mmap =  (LrfscDrvrMemoryMap     *) mcon->Address.VMEAddress;
   ram  =  (LrfcsDrvrRamIqArray*) mcon->Address.RamAddress;
a506 2
   if (pnum) pmsk = 1 << (pnum -1);
   else      pmsk = 1;
d517 2
a518 2
	       if (pmsk & ccon->Pulses) {
		  rb.Pulses = pmsk;
d539 1
a539 1
	    rb.Pulses = 0;
d550 1
a550 1
	    if (mcon->Pulses & pmsk) {
d552 1
a552 1
		  dst = &(mcon->Diags[sigc][cnum][pnum])[j];
d558 1
a558 1
	    mcon->ValidDiags[sigc][cnum][pnum] = vd;
a563 1
      pmsk = 1 << pnum;
@


1.9
log
@*** empty log message ***
@
text
@d107 1
a107 1
	int ps,v;
d109 8
a116 8
	disable(ps);
	{
		if ((v = *t)) {
			*t = 0;
			cancel_timeout(v);
		}
	}
	restore(ps);
d173 5
a177 15
	volatile LrfscDrvrModuleAddress *moad;        /* Module address, vector, level */
	volatile LrfscDrvrMemoryMap     *mmap;        /* Module Memory map */	
	LrfcsDrvrRamIqArray	*ram;
	LrfscDrvrBufIqArray	*buf;
	int ofs, i;

	moad = &(mcon->Address);
	mmap  = (LrfscDrvrMemoryMap *) moad->VMEAddress;
	mmap->RamSelect	= cnf;
	EIEIO;
	SYNC;

	ram = (LrfcsDrvrRamIqArray *) moad->RamAddress;
	buf = &(mcon->Configs[(int) cnf][cyc]);
	ofs = cyc * LrfscDrvrBUF_IQ_ENTRIES;
d179 1
a179 2
	for (i=0; i<LrfscDrvrBUF_IQ_ENTRIES; i++)
		*(ram[ofs + i]) = *(buf[i]);
d181 19
a199 1
	return OK;
d208 11
a218 11
	volatile LrfscDrvrModuleAddress *moad;        /* Module address, vector, level */
	volatile LrfscDrvrMemoryMap     *mmap;        /* Module Memory map */		
	LrfscDrvrMatrixCoefficients *mat;

	moad = &(mcon->Address);
	mmap = (LrfscDrvrMemoryMap *) moad->VMEAddress;
	mat  = &(mcon->Coefficients[(int) mnm]);
	CopyWords((unsigned short *) &(mmap->Matrix[(int) mnm]),
		  (unsigned short *) mat,
		  sizeof(LrfscDrvrMatrixCoefficients));
	return OK;
d227 2
a228 2
	volatile LrfscDrvrModuleAddress *moad;        /* Module address, vector, level */
	volatile LrfscDrvrMemoryMap     *mmap;        /* Module Memory map */		
d230 4
a233 4
	moad = &(mcon->Address);
	mmap = (LrfscDrvrMemoryMap *) moad->VMEAddress;
	mmap->SignalChoices[sgn] = (unsigned short) mcon->SignalChoices[sgn];
	return OK;
d242 40
a281 40
	volatile LrfscDrvrModuleAddress *moad;        /* Module address, vector, level */
	volatile LrfscDrvrMemoryMap     *mmap;        /* Module Memory map */
	int 							i,j;

	moad = &(mcon->Address);
	mmap  = (LrfscDrvrMemoryMap *) moad->VMEAddress;
	if (!recoset()) {

		mmap->State = LrfscDrvrStateCONFIG;
		EIEIO;
		SYNC;

		for (i=0; i<LrfscDrvrCONFIGS; i++) {
			mmap->RamSelect	= i;
			for (j=0; j<LrfscDrvrCYCLES; j++) {
				if (mcon->ValidConfigs[i][j]) {
					SetConfiguration(mcon, (LrfscDrvrConfig) i, j);
				}
			}
		}
		for (i=0; i<LrfscDrvrDiagSIGNAL_CHOICES; i++)
			SetSignalChoice(mcon, i);
		for (i=0; i<LrfscDrvrMatrixMATRICES; i++) 
			SetMatrixCoefficient(mcon, (LrfscDrvrMatrix) i);

		mmap->Control            = mcon->Control;
		mmap->Vector             = moad->InterruptVector;
		mmap->RamSelect          = mcon->RamSelect;
		mmap->ResCtrl.Time       = mcon->ResCtrl.Time;
		mmap->ResCtrl.Value      = mcon->ResCtrl.Value;
		mmap->SwitchCtrl         = mcon->SwitchCtrl;
		mmap->SoftSwitch         = mcon->SoftSwitch;
		mmap->SnapShot.DiagTime  = mcon->DiagTime;
		mmap->Pic.KP             = mcon->Pic.KP;
		mmap->Pic.KI             = mcon->Pic.KI;
		mmap->NextCycle          = 0;
		mmap->RfOnMaxLen         = mcon->RfOnMaxLen;
		mmap->State              = mcon->State;
		EIEIO;
		SYNC;
d283 7
a289 7
	} else {
		noreco();
		cprintf("LrfscDrvr: BUS-ERROR: Module:%d. VME Addr:%x Vect:%x Level:%x\n",
				mcon->ModuleIndex+1,
				moad->VMEAddress,
				moad->InterruptVector,
				moad->InterruptLevel);
d291 5
a295 5
		pseterr(ENXIO); /* No such device or address */
		return SYSERR;
	}
	noreco();
	return OK;
d315 1
a316 1

d328 1
d330 1
d332 1
a332 1
	/* Compute Virtual memory address as seen from system memory mapping */
d334 1
a334 1
	moad = &(mcon->Address);
d336 2
a337 1
	/* CES: build an address window (64 kbyte) for VME A24-D16 accesses */
d339 1
a339 2
	addr = (unsigned long) moad->VMEAddress;
	addr &= 0x007fffff;                      /* A24 - Bit-19 */
d341 16
a356 18
	bzero((char *)&param, sizeof(struct pdparam_master));

	param.iack   = 1;     /* no iack */
	param.rdpref = 0;     /* no VME read prefetch option */
	param.wrpost = 0;     /* no VME write posting option */
	param.swap   = 1;     /* VME auto swap option */
	param.dum[0] = 0;     /* window is sharable */

	vmeaddr = (void *) find_controller(addr,    /* Vme base address */
			0x10000, /* Module address space */
			0x39,    /* Address modifier A24 */
			0,       /* Offset */
			2,       /* Size is D16 */
			&param); /* Parameter block */
	if (vmeaddr == (void *) (-1)) {
		cprintf("LrfscDrvr: find_controller: ERROR: Module:%d. VME Addr:%x\n",
				index+1,
				addr);
d358 4
a361 4
		pseterr(ENXIO);        /* No such device or address */
		return SYSERR;
	}
	moad->VMEAddress = (unsigned short *) vmeaddr;
d363 1
a363 1
	mmap  = (LrfscDrvrMemoryMap *) moad->VMEAddress;
d365 2
a366 2
	mmap->State = 0;            /* Interrupts off */
	wrd   = mmap->IrqSource;    /* Clear interrup register */
d368 11
a378 11
	addr |= LrfscDrvrSTART_OF_RAM;
	ramaddr = (void *) find_controller(addr,    /* Vme RAM base address */
			LrfscDrvrTOTAL_RAM_SIZE, /* Module address space */
			0x39,                    /* Address modifier A24 */
			0,                       /* Offset */
			2,                       /* Size is D16 */
			&param);                 /* Parameter block */
	if (ramaddr == (void *) (-1)) {
		cprintf("LrfscDrvr: find_controller: ERROR: Module:%d. RAM Addr:%x\n",
				index+1,
				addr);
d380 4
a383 4
		pseterr(ENXIO); /* No such device or address */
		return SYSERR;
	}
	moad->RamAddress = (unsigned short *) ramaddr;
d385 4
a388 4
	if (!recoset()) {
		wrd = (unsigned short) *ramaddr;
		EIEIO;
		SYNC;
d390 7
a396 7
	} else {
		noreco();
		cprintf("LrfscDrvr: BUS-ERROR: Module:%d. RAM Addr:%x Vect:%x Level:%x\n",
				mcon->ModuleIndex+1,
				moad->RamAddress,
				moad->InterruptVector,
				moad->InterruptLevel);
d398 4
a401 4
		pseterr(ENXIO); /* No such device or address */
		return SYSERR;
	}
	noreco();
d403 9
a411 9
	coco = vme_intset((moad->InterruptVector), /* Vector */
			(void *)IntrHandler,     /* Address of ISR */
			(char *)mcon,            /* Parameter to pass */
			0);                      /* Don't save previous */
	if (coco < 0) {
		cprintf("LrfscDrvr: vme_intset: ERROR %d, MODULE %d\n",coco,index+1);
		pseterr(EFAULT);
		return SYSERR;
	}
d413 21
a433 21
	mcon->ModuleIndex				= index;
	mcon->State                                     = LrfscDrvrStateCONFIG;
	mcon->Control					= LrfscDrvrControlNONE;
	mcon->RamSelect					= LrfscDrvrRamSETPOINTS;
	mcon->ResCtrl.Time                              = 0xFF;
	mcon->SwitchCtrl                                = 0;
	mcon->SoftSwitch				= LrfscDrvrSotfSwitchMAIN_CLOSED;
	mcon->DiagTime					= 0xFF;
	mcon->RfOnMaxLen				= 0xFFFF;
	mcon->Pic.KI					= 0;
	mcon->Pic.KP					= 0;
	mcon->SignalChoices[0]			= LrfscDrvrDiagREFLECTED;
	mcon->SignalChoices[1]			= LrfscDrvrDiagFORWARD;
	mcon->SignalChoices[2]			= LrfscDrvrDiagCAVITY;
	mcon->SignalChoices[3]			= LrfscDrvrDiagOUTPUT;
	mcon->Coefficients[0].MatrixA	= 0x7fff;
	mcon->Coefficients[0].MatrixC	= 0x7fff;
	mcon->Coefficients[1].MatrixA	= 0x7fff;
	mcon->Coefficients[1].MatrixC	= 0x7fff;
	mcon->Coefficients[2].MatrixA	= 0x7fff;
	mcon->Coefficients[2].MatrixC	= 0x7fff;
d435 1
a435 1
	return Reset(mcon);
d443 1
a443 1
		LrfscDrvrClientContext *ccon) {
d445 10
a454 10
	LrfscDrvrModuleContext *mcon;
	int modi = 0;
	int clni;

	if (conx->Module) modi = conx->Module -1;
	mcon = &(Wa->ModuleContexts[modi]);
	if (mcon->State == LrfscDrvrStateCONFIG) {
		pseterr(EBUSY); /* Device busy, in local */
		return SYSERR;
	}
d456 4
a459 4
	clni = ccon->ClientIndex;
	mcon->Clients[clni] |= conx->Interrupt;
	if ((conx->Interrupt & LrfscDrvrInterruptPULSE) != 0)
		ccon->Pulses = conx->Pulses;
d461 1
a461 1
	return OK;
d469 1
a469 1
		LrfscDrvrClientContext *ccon) {
d471 12
a482 12
	LrfscDrvrModuleContext *mcon;
	int modi = 0;
	int clni;

	if (conx->Module) modi = conx->Module -1;
	mcon = &(Wa->ModuleContexts[modi]);

	clni = ccon->ClientIndex;
	mcon->Clients[clni] &= ~conx->Interrupt;
	if ((mcon->Clients[clni] & LrfscDrvrInterruptPULSE) == 0)
		ccon->Pulses = 0;
	return OK;
d491 53
a543 9
	volatile LrfscDrvrMemoryMap	*mmap;
	LrfscDrvrClientContext		*ccon;
	LrfscDrvrClientQueue		*queue;
	LrfscDrvrConnection			rb;
	unsigned int				i,j,iq,ci,si,vd,skpstr,skpcnt;
	unsigned short 				isrc, csrc, pnum, cnum, pmsk;
	LrfscDrvrDiagSignalChoice	sigc;
	LrfcsDrvrRamIqArray			*ram;
	LrfscDrvrIQPair				*src, *dst;
d545 23
a567 66
	mmap =  (LrfscDrvrMemoryMap	*) mcon->Address.VMEAddress;
	ram  =  (LrfcsDrvrRamIqArray*) mcon->Address.RamAddress;

	isrc = mmap->IrqSource;
	cnum = mmap->PresCycle;
	pnum = mmap->PulseNumber;
	pmsk = 1 << pnum;

	bzero((void *) &rb, sizeof(LrfscDrvrConnection));
	rb.Module = mcon->ModuleIndex + 1;

	while (isrc) {
		for (ci=0; ci<LrfscDrvrCLIENT_CONTEXTS; ci++) {
			ccon = &(Wa->ClientContexts[ci]);
			if (ccon->InUse) {
				csrc = isrc & mcon->Clients[ci];
				if (csrc & LrfscDrvrInterruptPULSE) {
					if (pmsk & ccon->Pulses) {
						rb.Pulses = pmsk;
						rb.Interrupt |= LrfscDrvrInterruptPULSE;
					}
				}
				if (csrc & LrfscDrvrInterruptSTART_CYCLE)
					rb.Interrupt |= LrfscDrvrInterruptSTART_CYCLE;

			}
			if (rb.Interrupt) {
				queue = &(ccon->Queue);
				if (queue->Size < LrfscDrvrCLIENT_QUEUE_SIZE) {
					queue->Size++;
					iq = queue->Head;
					queue->Queue[iq++] = rb;
					ssignal(&(ccon->Semaphore));
					if (iq < LrfscDrvrCLIENT_QUEUE_SIZE) queue->Head = iq;
					else                                 queue->Head = 0;
				} else {
					queue->Missed++;
				}
				rb.Interrupt = 0;
				rb.Pulses = 0;
			}
		}

		if (isrc & LrfscDrvrInterruptPULSE) {
			for (si=0; si<LrfscDrvrDiagSIGNAL_CHOICES; si++) {
				sigc = (LrfscDrvrDiagSignalChoice) mmap->SignalChoices[si];
				mmap->RamSelect = (LrfscDrvrRamSelection) si + LrfscDrvrRamDIAG1;
				skpstr = mcon->SkipStart;
				skpcnt = mcon->SkipCount;
				if (skpcnt == 0) skpcnt = (mmap->SnapShot.DiagTime/LrfscDrvrSKP_FACTOR);
				if (mcon->Pulses & pmsk) {
					for (i=skpstr, j=0; j<LrfscDrvrBUF_IQ_ENTRIES; i+=skpcnt, j++) {
						dst = &(mcon->Diags[sigc][cnum][pnum])[j];
						src = ram[i];
						*dst = *src;
						vd = 1;
					}
				} else vd = 0;
				mcon->ValidDiags[sigc][cnum][pnum] = vd;
			}
		}
		isrc = mmap->IrqSource;
		pnum = mmap->PulseNumber;
		cnum = mmap->PresCycle;
		pmsk = 1 << pnum;
	}
@


1.8
log
@*** empty log message ***
@
text
@d127 2
a128 2
		LrfscDrvrRawIoBlock    *riob,
		int rwflg) {
d130 35
a164 35
	volatile LrfscDrvrModuleAddress *moad; /* Module address, vector, level, ssch */
	volatile unsigned short         *mmap; /* Module Memory map */
	unsigned short                  *uary;
	int                             i, j, rval;

	moad = &(mcon->Address);
	if (riob->RamFlag)	mmap = moad->RamAddress;
	else				mmap = moad->VMEAddress;
	uary = riob->UserArray;
	rval = OK;

	if (!recoset()) {         /* Catch bus errors */
		for (i=0; i<riob->Size; i++) {
			j = riob->Offset+i;
			if (rwflg) mmap[j] = uary[i];
			else       uary[i] = mmap[j];
			EIEIO;
			SYNC;
		}
	} else {
		noreco();

		cprintf("LrfscDrvr: BUS-ERROR: Module:%d Offset:0x%X Address:0x%X ",
				(int) mcon->ModuleIndex+1,
				(int) j,
				(int) &(mmap[j]));

		if (riob->RamFlag)	cprintf("RAM\n");
		else       			cprintf("REG\n");

		pseterr(ENXIO);
		return SYSERR;
	}
	noreco();
	return riob->Size;
@


1.7
log
@*** empty log message ***
@
text
@d260 13
a272 12
		mmap->Control				= mcon->Control;
		mmap->Vector				= moad->InterruptVector;
		mmap->RamSelect				= mcon->RamSelect;
		mmap->ResCtrl.Time                      = mcon->ResCtrl.Time;
		mmap->ResCtrl.Value                     = mcon->ResCtrl.Value;
		mmap->SwitchCtrl			= mcon->SwitchCtrl;
		mmap->SoftSwitch			= mcon->SoftSwitch;
		mmap->SnapShot.DiagTime                 = mcon->DiagTime;
		mmap->Pic                               = mcon->Pic;
		mmap->NextCycle				= 0;
		mmap->RfOnMaxLen			= mcon->RfOnMaxLen;
		mmap->State                             = mcon->State;
d297 24
a320 8
	volatile LrfscDrvrModuleAddress *moad;        /* Module address, vector, level, ssch */
	volatile LrfscDrvrMemoryMap     *mmap;        /* Module Memory map */
	unsigned long                   addr;         /* VME base address */
	unsigned long                   coco;         /* Completion code */

	struct pdparam_master param; 
	volatile short *vmeaddr; 
	volatile short *ramaddr;
a321 1
	unsigned short wrd;
d1128 2
a1129 2
			mmap->Pic.KI = mcon->Pic.KI;
			mmap->Pic.KP = mcon->Pic.KP;
d1137 1
a1137 1
			picbuff->KI	= mcon->Pic.KI;
@


1.6
log
@*** empty log message ***
@
text
@d90 11
d208 3
a210 1
	mmap->Matrix[(int) mnm] = *mat;
d225 1
a225 1
	mmap->SignalChoices[sgn] = mcon->SignalChoices[sgn];
d341 4
@


1.5
log
@*** empty log message ***
@
text
@d1150 1
a1150 1
			for (i=confbuf->Start; i<confbuf->End; i++ ) {
d1162 1
a1162 1
			for (i=confbuf->Start; i<confbuf->End; i++ ) {
@


1.4
log
@*** empty log message ***
@
text
@d1125 7
@


1.3
log
@*** empty log message ***
@
text
@d67 1
d69 1
@


1.2
log
@*** empty log message ***
@
text
@d248 2
a249 2
		mmap->ResCtrl.ResCtrlTime	= mcon->ResCtrl.ResCtrlTime;
		mmap->ResCtrl.ResCtrl		= mcon->ResCtrl.ResCtrl;
d252 2
a253 2
		mmap->SnapShot.DiagTime 	= mcon->DiagTime;
		mmap->Pic					= mcon->Pic;
d256 1
a256 1
		mmap->State					= mcon->State;
d372 1
a372 1
	mcon->State						= LrfscDrvrStateCONFIG;
d375 2
a376 2
	mcon->ResCtrl.ResCtrlTime		= 0xFF;
	mcon->SwitchCtrl				= LrfscDrvrAnalogSwitchNORMAL;
a652 1
	int i, j;
d703 2
a704 3
	LrfscDrvrRawIoBlock			*riob;
	LrfscDrvrConnection			*conx;	
	LrfscDrvrClientQueue		*queue;
d707 1
a707 1
	LrfscDrvrResCtrl			*resctl;
d709 3
a711 3
	LrfscDrvrSoftSwitch			*softsw;
	LrfscDrvrMatrixCoefficientsBuf *coefbuf;
	LrfscDrvrMatrix 			matrx;
d713 6
a718 6
	LrfscDrvrPicSetBuf			*picbuff;
	LrfscDrvrConfigBuf			*confbuf;
	LrfscDrvrDiagBuf			*diagbuf;
	LrfscDrvrVersion			*verbuf;
	LrfscDrvrModuleAddress		*moadbuf;
	LrfscDrvrClientList			*clsbuf;
d720 1
a720 1
	LrfscDrvrIQPair				*src, *dst;
d804 8
d989 3
a991 2
			mmap->ResCtrl.ResCtrlTime	= mcon->ResCtrl.ResCtrlTime;
			mmap->ResCtrl.ResCtrl		= mcon->ResCtrl.ResCtrl;
d999 5
d1205 1
a1205 1
	case LrfscDrvrGET_VERSION:          /* LrfscDrvrVersion Get driver and VHDL versions */
d1215 1
@


1.1
log
@Initial revision
@
text
@d719 3
d724 1
a724 1
	int i, cynum, plnum;
d787 15
d806 16
d837 15
a851 1

d866 64
d1193 1
a1193 1
	case LrfscDrvrGET_GET_VERSION:		/* LrfscDrvrVersion Get driver and VHDL versions */
@
